import { r as registerInstance, c as createEvent, h, H as Host, g as getElement } from './index-8e730124.js';

const SINGLE_SELECTION_TYPE = 'single';
const MULTIPLE_SELECTION_TYPE = 'multiple';
const DEFAULT_SELECTION_TYPE = 'none';

const modusButtonGroupCss = "@import url(\"https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700\");:host{display:flex}:host slot::slotted(modus-button){display:block;margin:0;--btn-border-radius:0;--btn-border-left-width:0.0625rem;--btn-border-right-width:0}:host slot::slotted(modus-button:first-child){--btn-border-radius:0.25rem 0 0 0.25rem}:host slot::slotted(modus-button:last-child){--btn-border-radius:0 0.25rem 0.25rem 0;--btn-border-right-width:0.0625rem}:host slot::slotted(modus-button:only-child){--btn-border-radius:0.25rem}";
const ModusButtonGroupStyle0 = modusButtonGroupCss;

const ModusButtonGroup = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.buttonGroupClick = createEvent(this, "buttonGroupClick", 7);
        this.buttonSelectionChange = createEvent(this, "buttonSelectionChange", 7);
        /** Array to store selected buttons */
        this.selectedButtons = [];
        this.ariaDisabled = undefined;
        this.ariaLabel = undefined;
        this.buttonStyle = 'outline';
        this.color = 'primary';
        this.disabled = undefined;
        this.selectionType = DEFAULT_SELECTION_TYPE;
        this.size = 'medium';
    }
    selectionTypeChanged(newValue) {
        if (newValue === DEFAULT_SELECTION_TYPE) {
            this.selectedButtons.forEach((button) => button.setActive(false));
            this.selectedButtons = [];
        }
    }
    disabledChanged() {
        this.setupButtons(true);
    }
    sizeChanged() {
        this.setupButtons();
    }
    componentWillLoad() {
        this.setupButtons();
    }
    handleSlotChange() {
        this.setupButtons();
    }
    handleButtonClick(event) {
        const clickedButton = event.target;
        if (this.selectionType === DEFAULT_SELECTION_TYPE) {
            return;
        }
        switch (this.selectionType) {
            case SINGLE_SELECTION_TYPE:
                this.toggleSingleSelect(clickedButton);
                break;
            case MULTIPLE_SELECTION_TYPE:
                this.toggleMultiSelect(clickedButton);
                break;
        }
        this.buttonSelectionChange.emit(this.selectedButtons);
        this.buttonGroupClick.emit({ button: clickedButton, isSelected: this.selectedButtons.includes(clickedButton) });
    }
    setupButtons(reset) {
        const buttons = this.host.querySelectorAll('modus-button');
        this.renderButtons(buttons, reset);
    }
    renderButtons(buttons, reset) {
        const buttonType = this.determineButtonType();
        let foundSelected = false;
        buttons.forEach((button) => {
            if (reset) {
                button.ariaDisabled = this.ariaDisabled;
                button.disabled = this.disabled;
            }
            else {
                button.ariaDisabled = button.ariaDisabled || this.ariaDisabled;
                button.disabled = button.disabled || this.disabled;
            }
            button.buttonStyle = this.buttonStyle;
            button.color = this.color;
            button.size = this.size;
            button.type = buttonType;
            if (button.hasAttribute('selected') && !foundSelected && this.selectionType == SINGLE_SELECTION_TYPE) {
                button.setActive(true);
                this.selectedButtons.push(button);
                foundSelected = true;
            }
            else if (button.hasAttribute('selected') && this.selectionType == MULTIPLE_SELECTION_TYPE) {
                button.setActive(true);
                if (!this.selectedButtons.includes(button)) {
                    this.selectedButtons.push(button);
                }
            }
        });
    }
    determineButtonType() {
        return this.selectionType === DEFAULT_SELECTION_TYPE ? 'button' : 'toggle';
    }
    toggleMultiSelect(clickedButton) {
        const isSelected = this.selectedButtons.includes(clickedButton);
        clickedButton.setActive(!isSelected);
        this.selectedButtons = isSelected
            ? this.selectedButtons.filter((button) => button !== clickedButton)
            : [...this.selectedButtons, clickedButton];
    }
    toggleSingleSelect(clickedButton) {
        const wasActive = this.selectedButtons.includes(clickedButton);
        this.selectedButtons.forEach((button) => button.setActive(false));
        this.selectedButtons = wasActive ? [] : [clickedButton];
        if (!wasActive)
            clickedButton.setActive(true);
    }
    render() {
        return (h(Host, { key: '28d9db4ebc26a82398ba1f87bba763d4bc136e6b', "aria-label": this.ariaLabel, "aria-disabled": this.ariaDisabled ? this.ariaDisabled : this.disabled ? 'true' : undefined, role: "group" }, h("slot", { key: '510059102a090f5eb28ac476b534cfcc3d6c1f4c' })));
    }
    get host() { return getElement(this); }
    static get watchers() { return {
        "selectionType": ["selectionTypeChanged"],
        "disabled": ["disabledChanged"],
        "buttonStyle": ["sizeChanged"],
        "color": ["sizeChanged"],
        "size": ["sizeChanged"]
    }; }
};
ModusButtonGroup.style = ModusButtonGroupStyle0;

export { ModusButtonGroup as modus_button_group };
