import { r as registerInstance, c as createEvent, h, g as getElement, H as Host } from './index-8e730124.js';
import { I as IconSearch } from './icon-search-004e29b1.js';
import { g as generateElementId, c as createGuid } from './utils-3803a333.js';
import { d as IconCheck, M as ModusIconMap } from './ModusIconMap-a2d092e0.js';
import { y as CELL_EDIT_TYPE_TEXT, F as CELL_EDIT_TYPE_INT, G as CELL_EDIT_TYPE_DATE, I as CELL_EDIT_TYPE_AUTOCOMPLETE, J as CELL_EDIT_TYPE_SELECT, v as KEYBOARD_UP, w as KEYBOARD_DOWN, g as KEYBOARD_ENTER } from './modus-table.constants-c083d0c0.js';
import { c as createPopper } from './popper-0fbeff6d.js';
import './IconChevronLeft-f85188e7.js';
import './IconChevronRight-de7de2e8.js';
import './IconClose-9751af6c.js';
import './IconVisibilityOn-4d4ac4d9.js';

const modusAutocompleteCss = "@import url(\"https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700\");.autocomplete{position:relative}.autocomplete ul{list-style-type:none;margin:0;padding:0}.autocomplete label{color:var(--modus-autocomplete-label-color, #464b52);font-size:0.75rem;font-weight:700;margin-bottom:0.25rem}.autocomplete .label-container{display:inline-block;margin-bottom:0.25rem}.autocomplete .label-container .required{bottom:0.0625rem;color:var(--modus-autocomplete-validation-error-color, #da212c);margin-left:0.25rem;position:relative}.autocomplete .chips-container{align-items:center;background-color:var(--modus-autocomplete-bg, #fff);border:var(--modus-autocomplete-border, 0.0625rem solid var(--modus-input-border-color, #6a6e79));border-bottom-color:var(--modus-input-border-color, #6a6e79);border-radius:4px;box-sizing:border-box;display:flex;flex-flow:row wrap;height:auto;margin:0;min-height:32px;padding:0;position:relative;width:100%}.autocomplete .chips-container:focus-within{border-color:var(--modus-input-border-active-line-color, #217cbb);box-shadow:0 0 0 1px var(--modus-input-border-active-line-color, #217cbb)}.autocomplete .chips-container .icon-search{margin-left:4px;margin-right:0}.autocomplete .chips-container modus-chip{margin-left:4px;margin-right:4px}.autocomplete .chips-container .input{display:flex;flex:1;height:auto !important;position:relative;--input-font-size:var(--modus-autocomplete-font-size, 12px)}.autocomplete .chips-container .input::part(input-container){border:none !important;box-shadow:none;height:1.875rem}.autocomplete .error{color:var(--modus-autocomplete-validation-error-color, #da212c)}.autocomplete .options-container{background-color:var(--modus-list-item-bg, #fff);border-radius:4px;box-shadow:0 0 4px rgba(36, 35, 45, 0.3);font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";margin:0;padding:0;position:absolute;width:100%}.autocomplete .options-container .icon-check{display:inline-flex;margin-left:auto}.autocomplete .options-container .text-option{align-items:center;border:1px solid var(--modus-list-item-border-color, #e0e1e9);color:var(--modus-list-item-color, #252a2e);cursor:pointer;display:flex;flex-direction:row;font-size:0.75rem;min-height:2rem;padding:0 8px}.autocomplete .options-container .text-option.selected{background-color:var(--modus-blue-pale, #dcedf9)}.autocomplete .options-container .text-option:hover{background-color:var(--modus-list-item-hover-bg, #e0e1e9)}.autocomplete .options-container .text-option:focus{background-color:var(--modus-list-item-hover-bg, #e0e1e9)}.autocomplete .options-container .custom-option{border:1px solid var(--modus-list-item-border-color, #e0e1e9);cursor:pointer}.autocomplete .options-container .custom-option.selected{background-color:var(--modus-blue-pale, #dcedf9)}.autocomplete .options-container .custom-option:hover{background-color:var(--modus-list-item-hover-bg, #e0e1e9)}.autocomplete .options-container .custom-option:focus{background-color:var(--modus-list-item-hover-bg, #e0e1e9)}.autocomplete .options-container .no-results{align-items:center;border:1px solid var(--modus-list-item-border-color, #e0e1e9);border-radius:4px;display:flex;flex-direction:column;height:100px;justify-content:center}.autocomplete .options-container .no-results path{fill:var(--modus-autocomplete-no-results-message-color, #252a2e)}.autocomplete .options-container .no-results .message{color:var(--modus-autocomplete-no-results-message-color, #252a2e);font-size:1.25rem;font-weight:600;margin:0 0 0.375rem 0.25rem}.autocomplete .options-container .no-results .subtext{color:var(--modus-autocomplete-no-results-subtext-color, #252a2e);font-size:0.875rem}.autocomplete.large .chips-container .input::part(input-container){height:3rem}.autocomplete.large .icon-search{margin-left:8px}.autocomplete.large .options-container>.text-option{font-size:0.875rem;min-height:3rem;padding:0 1rem}.autocomplete[aria-disabled=true] .chips-container{background-color:var(--modus-input-disabled-bg, #e0e1e9);border-color:transparent;pointer-events:none;user-select:none}.autocomplete[aria-disabled=true] .chips-container .input::part(input-container){background-color:var(--modus-input-disabled-bg, #e0e1e9);border-color:transparent;color:var(--modus-input-disabled-color, #a3a6b1);pointer-events:none;user-select:none}";
const ModusAutocompleteStyle0 = modusAutocompleteCss;

const DATA_ID = 'data-id';
const DATA_SEARCH_VALUE = 'data-search-value';
const ModusAutocomplete = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.optionSelected = createEvent(this, "optionSelected", 7);
        this.valueChange = createEvent(this, "valueChange", 7);
        this.selectionsChanged = createEvent(this, "selectionsChanged", 7);
        this.listId = generateElementId() + '_list';
        this.classBySize = new Map([
            ['medium', 'medium'],
            ['large', 'large'],
        ]);
        this.displayNoResults = () => {
            var _a, _b, _c;
            return this.showNoResultsFoundMessage &&
                this.hasFocus &&
                !((_a = this.visibleOptions) === null || _a === void 0 ? void 0 : _a.length) &&
                !((_b = this.visibleCustomOptions) === null || _b === void 0 ? void 0 : _b.length) &&
                ((_c = this.value) === null || _c === void 0 ? void 0 : _c.length) > 0;
        };
        this.displayOptions = () => {
            var _a;
            const showOptions = this.showOptionsOnFocus || ((_a = this.value) === null || _a === void 0 ? void 0 : _a.length) > 0 || this.disableCloseOnSelect || this.ShowItemsOnKeyDown;
            return this.hasFocus && showOptions && !this.disabled;
        };
        this.handleCustomOptionClick = (option) => {
            const optionValue = option.getAttribute(DATA_SEARCH_VALUE);
            const optionId = option.getAttribute(DATA_ID);
            if (this.multiple) {
                this.addChipValue({ id: optionId, value: optionValue });
            }
            else {
                this.selectedOption = optionValue;
                this.disableFiltering = this.disableCloseOnSelect;
                this.handleSearchChange(optionValue);
                this.focusItemIndex = this.visibleCustomOptions.findIndex((el) => el.getAttribute(DATA_ID) === optionId);
            }
            this.hasFocus = this.disableCloseOnSelect;
            this.optionSelected.emit(optionId);
        };
        this.handleInputBlur = () => {
            this.hasFocus = !this.disableCloseOnSelect;
        };
        this.handleInputKeyDown = (event) => {
            if (event.defaultPrevented) {
                return; // Do nothing if event already handled
            }
            if (event.code.toUpperCase() === 'ARROWDOWN') {
                this.ShowItemsOnKeyDown = true;
                if (this.displayOptions() && !this.displayNoResults()) {
                    this.focusItemIndex = 0;
                    this.focusOptionItem();
                }
            }
            else if (event.code.toUpperCase() === 'ESCAPE') {
                this.ShowItemsOnKeyDown = false;
            }
        };
        this.handleOptionKeyDown = (event, option, isCustomOption = false) => {
            this.disableFiltering = !this.disableCloseOnSelect;
            switch (event.key.toUpperCase()) {
                case 'ENTER':
                case ' ':
                    if (isCustomOption) {
                        this.handleCustomOptionClick(option);
                    }
                    else {
                        this.handleOptionClick(option);
                    }
                    break;
                case 'ARROWDOWN':
                    if (isCustomOption) {
                        this.handleArrowDown(this.visibleCustomOptions);
                    }
                    else {
                        this.handleArrowDown(this.visibleOptions);
                    }
                    event.preventDefault();
                    break;
                case 'ARROWUP':
                    this.handleArrowUp();
                    break;
                default:
                    return;
            }
        };
        this.handleOptionClick = (option) => {
            if (this.multiple) {
                this.addChipValue(option);
            }
            else {
                this.selectedOption = option.value;
                this.disableFiltering = this.disableCloseOnSelect;
                this.focusItemIndex = this.visibleOptions.findIndex((el) => el.id === option.id);
                this.handleSearchChange(option.value);
            }
            this.hasFocus = this.disableCloseOnSelect;
            this.optionSelected.emit(option.id);
        };
        this.handleArrowDown = (options) => {
            this.focusItemIndex = Math.min(options.length - 1, this.focusItemIndex + 1);
            this.focusOptionItem();
        };
        this.handleArrowUp = () => {
            this.focusItemIndex = Math.max(0, this.focusItemIndex - 1);
            this.focusOptionItem();
        };
        this.focusOptionItem = () => {
            this.el.shadowRoot.querySelectorAll('[role="option"]')[this.focusItemIndex].focus();
        };
        this.handleSearchChange = (search) => {
            this.updateVisibleOptions(search);
            this.updateVisibleCustomOptions(search);
            this.value = search;
            this.valueChange.emit(search);
        };
        this.handleTextInputFocus = () => {
            var _a;
            const hasDefaultTextInput = ((_a = this.value) === null || _a === void 0 ? void 0 : _a.length) > 0 && !this.disableCloseOnSelect;
            if (hasDefaultTextInput) {
                this.disableFiltering = true;
            }
        };
        this.handleTextInputValueChange = (event) => {
            // Cancel the modus-text-input's value change event or else it will bubble to consumer.
            event.stopPropagation();
            this.disableFiltering = !this.disableCloseOnSelect;
            this.handleSearchChange(event.detail);
        };
        this.updateVisibleCustomOptions = (search = '') => {
            var _a, _b, _c;
            if (!this.hasFocus) {
                return;
            }
            const slotted = (_a = this.el.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('slot');
            if (!slotted || typeof slotted.assignedNodes !== 'function') {
                return;
            }
            this.customOptions = slotted.assignedNodes().filter((node) => node.nodeName !== '#text');
            search = search || '';
            const isSearchEmpty = search.length === 0;
            if (isSearchEmpty) {
                this.selectedOption = '';
            }
            if (!this.disableFiltering) {
                this.visibleCustomOptions = (_b = this.customOptions) === null || _b === void 0 ? void 0 : _b.filter((o) => {
                    return o.getAttribute(DATA_SEARCH_VALUE).toLowerCase().includes(search.toLowerCase());
                });
            }
            else {
                this.visibleCustomOptions = this.customOptions;
            }
            if (((_c = this.visibleCustomOptions) === null || _c === void 0 ? void 0 : _c.length) === 0) {
                this.showNoResultsFoundMessage = true;
            }
            this.containsSlottedElements = this.customOptions.length > 0;
        };
        this.updateVisibleOptions = (search = '') => {
            var _a, _b;
            if (!this.hasFocus) {
                return;
            }
            search = search || '';
            const isSearchEmpty = search.length === 0;
            if (isSearchEmpty) {
                this.selectedOption = '';
            }
            if (!this.disableFiltering) {
                this.visibleOptions = (_a = this.options) === null || _a === void 0 ? void 0 : _a.filter((o) => {
                    return o.value.toLowerCase().includes(search.toLowerCase());
                });
            }
            else {
                this.visibleOptions = this.options;
            }
            if (((_b = this.visibleOptions) === null || _b === void 0 ? void 0 : _b.length) === 0) {
                this.showNoResultsFoundMessage = true;
            }
        };
        // Do not display the slot for the custom options. We use this hidden slot to reference the slot's children.
        this.CustomOptionsSlot = () => (h("div", { style: { display: 'none' } }, h("slot", { onSlotchange: () => this.updateVisibleCustomOptions(this.value) })));
        this.TextInput = () => (h("modus-text-input", { class: "input", autocomplete: "off", clearable: this.clearable && !this.readOnly && !!this.value, errorText: this.hasFocus ? '' : this.errorText, includeSearchIcon: false, onFocus: this.handleTextInputFocus, onValueChange: (searchEvent) => this.handleTextInputValueChange(searchEvent), placeholder: this.placeholder, size: this.size, type: "search", value: this.value, onBlur: this.handleInputBlur, role: "combobox", "aria-autocomplete": "list", "aria-controls": this.listId, "aria-expanded": this.displayOptions() }));
        this.scrollToOptionSelected = () => {
            if (this.multiple || this.focusItemIndex === 0) {
                return;
            }
            const optionList = this.el.shadowRoot.querySelector(`.options-container`);
            const selectedOption = optionList.querySelector('li.selected');
            if (selectedOption) {
                selectedOption.scrollIntoView({ behavior: 'smooth', inline: 'nearest' });
            }
        };
        this.multiple = undefined;
        this.ariaLabel = undefined;
        this.clearable = false;
        this.disabled = undefined;
        this.disableCloseOnSelect = undefined;
        this.dropdownMaxHeight = '300px';
        this.dropdownZIndex = '1';
        this.errorText = undefined;
        this.includeSearchIcon = true;
        this.label = undefined;
        this.noResultsFoundText = 'No results found';
        this.noResultsFoundSubtext = 'Check spelling or try a different keyword';
        this.options = undefined;
        this.selectedChips = [];
        this.selectedOption = undefined;
        this.showOptionsOnFocus = undefined;
        this.placeholder = undefined;
        this.readOnly = undefined;
        this.required = undefined;
        this.showNoResultsFoundMessage = true;
        this.size = 'medium';
        this.value = undefined;
        this.containsSlottedElements = false;
        this.hasFocus = false;
        this.visibleOptions = [];
        this.customOptions = [];
        this.visibleCustomOptions = [];
        this.disableFiltering = false;
        this.focusItemIndex = 0;
        this.ShowItemsOnKeyDown = false;
    }
    watchOptions() {
        this.convertOptions();
        this.updateVisibleOptions(this.value);
    }
    onValueChange() {
        if (this.hasFocus && !this.disableCloseOnSelect) {
            this.disableFiltering = false;
            this.updateVisibleOptions(this.value);
            this.updateVisibleCustomOptions(this.value);
        }
    }
    componentWillLoad() {
        this.convertOptions();
    }
    componentDidRender() {
        if (this.displayOptions()) {
            this.scrollToOptionSelected();
        }
    }
    onMouseDown(event) {
        if (!this.hasFocus) {
            return;
        }
        if (this.el !== event.target || !this.el.contains(event.target)) {
            this.hasFocus = false;
            this.ShowItemsOnKeyDown = false;
        }
    }
    convertOptions() {
        var _a;
        if (this.options && this.options.length > 0) {
            if (typeof this.options[0] === 'string') {
                this.options = (_a = this.options) === null || _a === void 0 ? void 0 : _a.map((option) => ({
                    id: option,
                    value: option,
                }));
            }
        }
    }
    addChipValue(value) {
        if (this.selectedChips.includes(value)) {
            return;
        }
        this.selectedChips = [...this.selectedChips, value];
        this.valueChange.emit(this.selectedChips.map((opt) => opt.value).join(','));
        this.selectionsChanged.emit(this.selectedChips.map((opt) => opt.id));
        this.value = '';
    }
    handleClear() {
        this.selectedChips = [];
        this.selectedOption = '';
    }
    handleCloseClick(chipValue) {
        if (this.selectedChips.length != 0) {
            this.selectedChips = this.selectedChips.filter((chip) => chip.id !== chipValue.id);
            this.valueChange.emit(this.selectedChips.join(','));
            this.selectionsChanged.emit(this.selectedChips.map((opt) => opt.id));
        }
    }
    valueChangedHandler(event) {
        if (event.detail == null) {
            this.handleClear();
        }
    }
    render() {
        var _a, _b;
        const classes = `autocomplete ${this.classBySize.get(this.size)}`;
        return (h("div", { key: '165a50a77a5ded35f0c8537c76100e4ee3e4554d', "aria-disabled": this.disabled ? 'true' : undefined, "aria-invalid": !!this.errorText, "aria-label": this.ariaLabel || undefined, "aria-readonly": this.readOnly, "aria-required": this.required, class: classes, onFocusin: () => {
                if (this.hasFocus) {
                    return;
                }
                this.hasFocus = true;
                this.updateVisibleOptions(this.value);
                this.updateVisibleCustomOptions(this.value);
            }, onFocusout: () => {
                if (this.hasFocus) {
                    this.hasFocus = this.disableCloseOnSelect;
                }
            }, onKeyDown: (e) => this.handleInputKeyDown(e) }, this.label || this.required ? (h("div", { class: 'label-container' }, this.label ? h("label", null, this.label) : null, this.required ? h("span", { class: "required" }, "*") : null)) : null, h("div", { key: 'c6c10f829e890b7cfbc69f3adb42ad3b564b025d', class: "chips-container" }, this.includeSearchIcon ? h(IconSearch, { size: "16" }) : null, this.selectedChips.map((chip) => (h("modus-chip", { value: chip.value, chipId: chip.id, size: this.size === 'large' ? 'medium' : 'small', "show-close": true, onCloseClick: () => this.handleCloseClick(chip) }))), this.TextInput()), h("div", { key: '8180012cd41df4c11c2d120a194e674abb69a1d0', class: 'error' }, this.errorText ? h("label", { class: "sub-text error" }, this.errorText) : null), h("div", { key: '5447a91e2fc49f013869f2a2102636fccced1534', class: "options-container", style: { maxHeight: this.dropdownMaxHeight, zIndex: this.dropdownZIndex, overflowY: 'auto' } }, h("ul", { key: '4bf60b01f2a76d18384a34f5c604c5da164e481f', id: this.listId, "aria-label": "options", role: "listbox" }, this.displayOptions() &&
            ((_a = this.visibleOptions) === null || _a === void 0 ? void 0 : _a.map((option) => {
                let className;
                let isSelected;
                if (this.multiple) {
                    isSelected = this.selectedChips.includes(option);
                    className = 'text-option' + (isSelected ? ' selected' : '');
                }
                else {
                    isSelected = this.selectedOption === option.value;
                    className = 'text-option' + (isSelected ? ' selected' : '');
                }
                return (h("li", { class: className, tabindex: "-1", role: "option", onClick: () => this.handleOptionClick(option), onKeyDown: (e) => this.handleOptionKeyDown(e, option) }, option.value, isSelected && h(IconCheck, { size: "16" })));
            })), this.displayOptions() &&
            ((_b = this.visibleCustomOptions) === null || _b === void 0 ? void 0 : _b.map((option) => {
                const optionValue = option.getAttribute(DATA_SEARCH_VALUE);
                let className;
                if (this.multiple) {
                    className = 'custom-option' + (this.selectedChips.includes(optionValue) ? ' selected' : '');
                }
                else {
                    className = 'custom-option' + (this.selectedOption === optionValue ? ' selected' : '');
                }
                return (h("li", { class: className, tabindex: "-1", role: "option", onClick: () => this.handleCustomOptionClick(option), onKeyDown: (e) => this.handleOptionKeyDown(e, option, true), innerHTML: option.outerHTML }));
            }))), this.displayNoResults() && h(NoResultsFound, { text: this.noResultsFoundText, subtext: this.noResultsFoundSubtext })), this.CustomOptionsSlot()));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "options": ["watchOptions"],
        "value": ["onValueChange"]
    }; }
};
const NoResultsFound = (props) => (h("div", { class: "no-results" }, h("div", { style: { display: 'flex' } }, h(IconSearch, { size: "28px" }), h("div", { class: "message" }, props.text)), h("div", { class: "subtext" }, props.subtext)));
ModusAutocomplete.style = ModusAutocompleteStyle0;

const monthsFull = [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December',
];
const monthsShort = monthsFull.map((m) => m.substring(0, 3));
function pad(val) {
    if (val < 10)
        return `0${val}`;
    return val.toString();
}
//date.toLocaleString('en-US', { month: 'short' })
const Tokens = {
    mmmm: { regex: `(${monthsFull.join('|')})`, type: 'month' },
    mmm: { regex: `(${monthsShort.join('|')})`, type: 'month' },
    mm: { regex: '(1[0-2]|0?[1-9])', type: 'month' },
    m: { regex: '(1[0-2]|0?[1-9])', type: 'month' },
    dd: { regex: '(3[01]|0?[1-9]|[12][0-9])', type: 'date' },
    d: { regex: '(3[01]|0?[1-9]|[12][0-9])', type: 'date' },
    yy: { regex: '(\\d{2})', type: 'year' },
    yyyy: { regex: '(\\d{4})', type: 'year' },
};
const TokenFormatting = {
    m: function (val) {
        return `${val}`;
    },
    mm: function (val) {
        return pad(val);
    },
    mmm: function (val) {
        return monthsShort[val - 1];
    },
    mmmm: function (val) {
        return monthsFull[val - 1];
    },
    d: function (val) {
        return `${val}`;
    },
    dd: function (val) {
        return pad(val);
    },
    yy: function (val) {
        return pad(val).substring(2);
    },
    yyyy: function (val, fillerYear) {
        if (val < 100) {
            const fill = fillerYear || new Date().getFullYear();
            return `${String(fill).substring(0, 2)}${pad(val)}`;
        }
        else
            return `${val}`;
    },
};
const defaultParser = function (val) {
    return parseFloat(val);
};
const TokenParser = {
    m: defaultParser,
    mm: defaultParser,
    mmm: function (val) {
        return monthsShort.findIndex((m) => m.toUpperCase() === (val === null || val === void 0 ? void 0 : val.toUpperCase())) + 1;
    },
    mmmm: function (val) {
        return monthsFull.findIndex((m) => m.toUpperCase() === (val === null || val === void 0 ? void 0 : val.toUpperCase())) + 1;
    },
    d: defaultParser,
    dd: defaultParser,
    yy: defaultParser,
    yyyy: defaultParser,
};

const ISO_DATE_FORMAT = /^(\d{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])/;
class DateInputFormatter {
    constructor(fillerDateString, format) {
        const [regex, tokens, separators] = this.buildRegexAndTokens(format);
        if (regex && tokens) {
            this._dateRegExp = regex;
            this._dateTokens = tokens;
            this._displayFormat = format;
            this._tokenSeparators = separators;
        }
        this._fillerDate = this.getFillerDate(fillerDateString);
    }
    /**
     * Note: Auto formatting is not used yet due to the challenges in handling formats like 'm' and 'd' where the user can input single or double-digit
     */
    autoFormatInput(val, autoFormat) {
        if (!val || !autoFormat)
            return val;
        const separator = this._tokenSeparators.get(val.length);
        if (separator) {
            return val + separator;
        }
        return val;
    }
    /**
     * Build a regular expression from the date format
     * Returns an array of regular expression, date tokens, token separators
     */
    buildRegexAndTokens(format) {
        const dtTokens = new Map();
        const regexParts = [];
        const separators = new Map();
        for (let i = 0; i < format.length; i++) {
            let token = format[i];
            const tokens = [token];
            while (format[i + 1] === token) {
                tokens.push(token);
                ++i;
            }
            const validToken = tokens.join('');
            const tokenInfo = Tokens[validToken];
            if (tokenInfo && tokenInfo.regex) {
                dtTokens.set(tokenInfo.type, {
                    index: dtTokens.size,
                    tokenString: validToken,
                });
                token = tokenInfo.regex;
            }
            else {
                separators.set(i, token);
            }
            regexParts.push(token);
        }
        return [`^${regexParts.join('')}$`, dtTokens, separators];
    }
    /** Format value in ISO 8601 date format to the display format */
    formatDisplayString(val) {
        const regex = new RegExp(ISO_DATE_FORMAT);
        const parse = regex.exec(val);
        if (parse) {
            parse.shift();
            const parts = {
                year: parseFloat(parse[0]),
                month: parseFloat(parse[1]),
                date: parseFloat(parse[2]),
            };
            let output = this._displayFormat;
            this._dateTokens.forEach(({ tokenString }, key) => {
                const formatting = TokenFormatting[tokenString];
                output = output.replace(tokenString, formatting(parts[key], key === 'year' ? this._fillerDate.getFullYear() : null));
            });
            return output;
        }
        return null;
    }
    /** Parse display string to ISO 8601 date format YYYY-MM-DD */
    parseDisplayString(val) {
        if (this._dateRegExp && val) {
            const regexObj = new RegExp(this._dateRegExp, 'i');
            const output = regexObj.exec(val);
            if (output) {
                // parsed[0] always contains the whole string
                output.shift();
                const monthToken = this._dateTokens.get('month');
                const dateToken = this._dateTokens.get('date');
                const yearToken = this._dateTokens.get('year');
                const month = monthToken
                    ? TokenParser[monthToken.tokenString](output[monthToken.index])
                    : this._fillerDate.getMonth() + 1;
                const date = dateToken ? TokenParser[dateToken.tokenString](output[dateToken.index]) : this._fillerDate.getDate();
                const year = yearToken
                    ? TokenParser[yearToken.tokenString](output[yearToken.index])
                    : this._fillerDate.getFullYear();
                const isoDateString = `${TokenFormatting.yyyy(year, this._fillerDate.getFullYear())}-${TokenFormatting.mm(month)}-${TokenFormatting.dd(date)}`;
                return Date.parse(isoDateString) ? isoDateString : null;
            }
        }
        return null;
    }
    /**
     * Filler date is used as fillers for parts not in the display format when constructing a full date string,
     * ex: 'yyyy-mm' format doesn't have a date part, hence the date is picked from filler  */
    getFillerDate(val) {
        return this.parseIsoToDate(val) || new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0);
    }
    parseIsoToDate(val) {
        if (!val) {
            return null;
        }
        const regex = new RegExp(ISO_DATE_FORMAT);
        const parse = regex.exec(val);
        if (parse) {
            parse.shift();
            return new Date(parseFloat(parse[0]), parseFloat(parse[1]) - 1, parseFloat(parse[2]));
        }
        return null;
    }
}

const modusDateInputCss = "@import url(\"https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700\");.modus-date-input{box-sizing:border-box;display:inline-flex;flex-direction:column;font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";position:relative;width:100%}.modus-date-input button{background:0;border:0;cursor:pointer;margin:0;padding:0}.modus-date-input label{color:var(--modus-input-label-color, #464b52);font-size:0.75rem;font-weight:700;margin-bottom:0.25rem}.modus-date-input label span{color:var(--modus-input-border-color, #6a6e79);margin:0.25rem}.modus-date-input .label-container{display:flex}.modus-date-input .label-container .required{bottom:0.0625rem;color:var(--modus-input-validation-error-color, #da212c);margin-left:0.25rem;position:relative}.modus-date-input .input-container{align-items:center;background-color:var(--modus-input-bg, #fff);border:0.0625rem solid var(--modus-input-border-color, #6a6e79);border-radius:4px;box-sizing:border-box;display:flex;flex-direction:row;height:2rem;position:relative;width:100%}.modus-date-input .input-container input{background-color:transparent;border:none;color:var(--modus-input-color, #252a2e);font-size:0.75rem;outline:none;padding:0 0.5rem;width:100%}.modus-date-input .input-container input.has-right-icon{padding-right:0}.modus-date-input .input-container input::placeholder{color:var(--modus-input-hint-text-color, #a3a6b1)}.modus-date-input .input-container .icons{align-items:center;background-color:var(--modus-input-bg, #fff);border-bottom-right-radius:4px;border-top-right-radius:4px;display:flex;font-size:1rem;height:100%;justify-content:center;width:2rem}.modus-date-input .input-container .icons svg.icon-calendar{cursor:pointer !important;padding:0 0.375rem}.modus-date-input .input-container .icons svg.icon-calendar path{fill:var(--modus-date-input-calendar-icon-color, #6a6e79)}.modus-date-input .input-container:hover{cursor:text}.modus-date-input .input-container:focus-within{border-color:var(--modus-input-border-active-color, #217cbb);box-shadow:0 0 0 1px var(--modus-input-border-active-color, #217cbb)}.modus-date-input .input-container:focus-within svg.icon-calendar path{fill:var(--modus-input-border-active-color, #217cbb)}.modus-date-input .input-container.error{border-color:var(--modus-input-validation-error-color, #da212c);box-shadow:0 0 0 1px var(--modus-input-validation-error-color, #da212c)}.modus-date-input .input-container.error svg.icon-calendar path{fill:var(--modus-input-validation-error-color, #da212c)}.modus-date-input .input-container.valid{border-color:var(--modus-input-validation-success-color, #006638);box-shadow:0 0 0 1px var(--modus-input-validation-success-color, #006638)}.modus-date-input .input-container.valid svg.icon-calendar path{fill:var(--modus-input-validation-success-color, #006638)}.modus-date-input .input-container.large{height:3rem}.modus-date-input .input-container.large input{font-size:0.875rem;padding:0 1rem}.modus-date-input .input-container:has(input[readonly]){background-color:var(--modus-input-readonly-bg, #e0e1e9);border-color:transparent}.modus-date-input .sub-text{font-size:0.75rem}.modus-date-input .sub-text:has(label){margin-top:0.25rem}.modus-date-input .sub-text .helper{color:var(--modus-input-label-color, #464b52);display:block;font-weight:600;margin:0}.modus-date-input .sub-text .error{color:var(--modus-input-validation-error-color, #da212c)}.modus-date-input .sub-text .valid{color:var(--modus-input-validation-success-color, #006638)}.modus-date-input span.required{color:var(--modus-input-validation-error-color, #da212c)}.modus-date-input.large{font-size:0.875rem;height:48px}.modus-date-input.disabled{pointer-events:none}.modus-date-input.disabled .input-container{background-color:var(--modus-input-disabled-bg, #e0e1e9);border-color:transparent}.modus-date-input.disabled .input-container svg path{fill:var(--modus-input-disabled-color, #a3a6b1)}.modus-date-input.disabled .input-container .icons{background-color:var(--modus-input-disabled-bg, #e0e1e9);cursor:default}.modus-date-input.disabled .input-container input{background-color:transparent;border-radius:0;color:var(--modus-input-disabled-color, #a3a6b1);height:100%}.modus-date-input input{background-position:right calc(0.375em + 0.1875rem) center;background-repeat:no-repeat;background-size:calc(0.75em + 0.375rem) calc(0.75em + 0.375rem);font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";padding-right:calc(1.5em + 0.75rem)}";
const ModusDateInputStyle0 = modusDateInputCss;

const ModusDateInput = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calendarIconClicked = createEvent(this, "calendarIconClicked", 7);
        this.dateInputBlur = createEvent(this, "dateInputBlur", 7);
        this.valueChange = createEvent(this, "valueChange", 7);
        this.valueError = createEvent(this, "valueError", 7);
        this.classBySize = new Map([
            ['medium', 'medium'],
            ['large', 'large'],
        ]);
        this._dateInputId = `date-input-${Math.random().toString().slice(2, 7)}`;
        this._altFormatters = [];
        // TODO: Auto formatting for single tokens 'm' and 'd' is tricky because user can input double digits
        this.autoFormat = false;
        this.allowedCharsRegex = undefined;
        this.ariaLabel = undefined;
        this.autoFocusInput = undefined;
        this.disabled = undefined;
        this.disableValidation = undefined;
        this.errorText = undefined;
        this.fillerDate = undefined;
        this.format = 'mm/dd/yyyy';
        this.altFormats = undefined;
        this.helperText = undefined;
        this.label = undefined;
        this.placeholder = undefined;
        this.readOnly = undefined;
        this.required = undefined;
        this.showCalendarIcon = undefined;
        this.size = 'medium';
        this.type = 'single';
        this.validText = undefined;
        this.min = undefined;
        this.max = undefined;
        this.value = undefined;
        this._dateDisplay = undefined;
    }
    handleFillerDateChange(val) {
        this._formatter = new DateInputFormatter(val, this.format);
    }
    handleFormatChange(val) {
        this._formatter = new DateInputFormatter(this.fillerDate, val);
        this.handleValueChange(this.value);
    }
    handleAltFormatsChange(altFormats) {
        if (!altFormats) {
            return;
        }
        this._altFormatters = altFormats
            .split('|')
            .map((format) => format.trim())
            .filter(Boolean)
            .map((format) => new DateInputFormatter(this.fillerDate, format));
    }
    handleValueChange(val) {
        if (!this._isEditing) {
            this._dateDisplay = this._formatter.formatDisplayString(val);
        }
        this.valueChange.emit({
            value: val,
            type: this.type,
            inputString: this._dateDisplay,
        });
    }
    componentWillLoad() {
        this.handleFormatChange(this.format);
        this.handleAltFormatsChange(this.altFormats);
        this._dateDisplay = this._formatter.formatDisplayString(this.value);
        this.setDefaultAllowedKeysRegex(this.autoFormat);
    }
    /** Methods */
    /** Focus the input. */
    async focusInput() {
        this._dateInput.focus();
    }
    /** Validate the input. */
    async validate() {
        this.validateInput(this._dateDisplay);
    }
    /** Handlers */
    handleCalendarClick() {
        this.calendarIconClicked.emit({
            value: this.value,
            type: this.type,
            inputString: this._dateDisplay,
        });
    }
    handleDefaultKeyDown(e, callback) {
        const code = e.code.toUpperCase();
        if (code === 'ENTER' || code === 'SPACE')
            callback();
    }
    handleBlur() {
        this._isEditing = false;
        this.updateDateFromAltFormats();
        this.validateInput(this._dateDisplay);
        this.dateInputBlur.emit({
            value: this.value,
            type: this.type,
            inputString: this._dateDisplay,
        });
    }
    handleInputKeyPress(event) {
        const keyIsValid = this.keyIsValidDateCharacter(event.key);
        if (!keyIsValid) {
            event.preventDefault();
        }
        return keyIsValid;
    }
    handleInputKeyDown(event) {
        if (event.key.toLowerCase() === 'enter') {
            this.handleBlur();
        }
    }
    handleOnInput(event) {
        var _a;
        this._isEditing = true;
        event.stopPropagation();
        event.preventDefault();
        const inputString = (_a = event.currentTarget) === null || _a === void 0 ? void 0 : _a.value;
        this._dateDisplay = inputString;
        this.value = this._formatter.parseDisplayString(inputString.trim());
    }
    // Helpers
    clearValidation() {
        this.errorText = null;
    }
    /** Check if the input string matches any of the alternative formats. */
    updateDateFromAltFormats() {
        if (this.value) {
            this._dateDisplay = this._formatter.formatDisplayString(this.value);
            return;
        }
        if (!this._dateDisplay)
            return;
        const displayDate = this._dateDisplay.trim();
        // if there is no value for the default format, check the alternative formats
        for (const formatter of this._altFormatters) {
            const result = formatter.parseDisplayString(displayDate);
            if (result) {
                this._dateDisplay = this._formatter.formatDisplayString(result);
                this.value = result;
                return;
            }
        }
    }
    keyIsValidDateCharacter(key) {
        if (!this.allowedCharsRegex)
            return true;
        const dateCharacterRegex = new RegExp(this.allowedCharsRegex);
        return dateCharacterRegex.test(key);
    }
    setDefaultAllowedKeysRegex(autoFormat) {
        if (!this.allowedCharsRegex) {
            this.allowedCharsRegex = autoFormat ? /\d/gi : /.*/;
        }
    }
    validateInput(inputString) {
        if (this.disableValidation)
            return;
        if (!inputString) {
            if (this.required) {
                this.errorText = 'Required';
                this.valueError.emit(this.errorText);
            }
            else {
                this.clearValidation();
            }
        }
        else if (!this.value) {
            this.errorText = 'Invalid date';
            this.valueError.emit(this.errorText);
        }
        else {
            this.validateMinMax();
        }
    }
    validateMinMax() {
        const min = this._formatter.parseIsoToDate(this.min);
        const max = this._formatter.parseIsoToDate(this.max);
        const value = this._formatter.parseIsoToDate(this.value);
        if (min && min > value) {
            min.setUTCDate(min.getDate() - 1);
            this.errorText = `Select a date after ${this._formatter.formatDisplayString(min.toISOString())}`;
            this.valueError.emit(this.errorText);
        }
        else if (max && max < value) {
            max.setUTCDate(max.getDate() + 1);
            this.errorText = `Select a date before ${this._formatter.formatDisplayString(max.toISOString())}`;
            this.valueError.emit(this.errorText);
        }
        else {
            this.clearValidation();
        }
    }
    render() {
        var _a;
        const className = `modus-date-input ${this.disabled ? 'disabled' : ''}`;
        return (h("div", { key: 'bf68b3a862d5ac7dafaf157720b5a6c6d0c0b0b2', class: className }, this.label || this.required ? (h("div", { class: "label-container" }, this.label ? h("label", { htmlFor: this._dateInputId }, this.label) : null, this.required ? h("span", { class: "required" }, "*") : null, this.helperText ? h("label", { class: "sub-text helper" }, this.helperText) : null)) : null, h("div", { key: 'ab7291ae18d2e9b83930142fff070068fbc49b01', class: `input-container ${this.errorText ? 'error' : this.validText ? 'valid' : ''} ${this.classBySize.get(this.size)}`, part: `input-container ${this.errorText ? 'error' : this.validText ? 'valid' : ''}` }, h("input", { key: 'a6cfc3cf6dc78f1a76d65635ec34ccecf96ddd36', "aria-invalid": !!this.errorText, "aria-label": this.ariaLabel || undefined, "aria-required": (_a = this.required) === null || _a === void 0 ? void 0 : _a.toString(), autofocus: this.autoFocusInput, class: { 'has-right-icon': this.showCalendarIcon }, disabled: this.disabled, id: this._dateInputId, onBlur: () => this.handleBlur(), onInput: (event) => this.handleOnInput(event), onKeyPress: (e) => this.handleInputKeyPress(e), onKeyDown: (e) => this.handleInputKeyDown(e), placeholder: this.placeholder, readonly: this.readOnly, ref: (el) => (this._dateInput = el), tabIndex: 0, type: "text", value: this._dateDisplay }), this.showCalendarIcon && (h("span", { class: "icons", tabIndex: 0, onKeyDown: (e) => this.handleDefaultKeyDown(e, () => this.handleCalendarClick()), onClick: () => this.handleCalendarClick(), role: "button", "aria-label": "Open calendar" }, h(ModusIconMap, { icon: "calendar", size: "16" })))), h("div", { key: '97083a2b1e4c71cb48a98b7e4d6ff2b714378730', class: "sub-text", part: "sub-text" }, this.errorText ? (h("label", { class: "error" }, this.errorText)) : this.validText ? (h("label", { class: "valid" }, this.validText)) : null)));
    }
    get element() { return getElement(this); }
    static get watchers() { return {
        "fillerDate": ["handleFillerDateChange"],
        "format": ["handleFormatChange"],
        "altFormats": ["handleAltFormatsChange"],
        "value": ["handleValueChange"]
    }; }
};
ModusDateInput.style = ModusDateInputStyle0;

const MONTH_NAMES = [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December',
];
class ModusDatePickerCalendar {
    constructor(calendar) {
        if (calendar) {
            this.gotoDate(calendar.currentDate.getFullYear(), calendar.currentDate.getMonth());
        }
        else {
            const today = new Date();
            this.gotoDate(today.getFullYear(), today.getMonth());
        }
    }
    get year() {
        return this.currentDate.getFullYear().toString();
    }
    get month() {
        return MONTH_NAMES[this.currentDate.getMonth()];
    }
    get selectedYear() {
        return this.currentDate.getFullYear();
    }
    get selectedMonth() {
        return this.currentDate.getMonth();
    }
    get dates() {
        return this.currentMonthDates;
    }
    addMonthOffset(offset) {
        this.gotoDate(this.currentDate.getFullYear(), this.currentDate.getMonth() + offset);
        return this;
    }
    addYearOffset(offset) {
        this.gotoDate(this.currentDate.getFullYear() + offset, this.currentDate.getMonth());
        return this;
    }
    gotoDate(year, month) {
        this.currentDate = new Date(year, month, 1);
        this.calculateDates();
    }
    getDaysOfWeek(locale, firstDayOfWeek = 0) {
        /**
         * Nov 1st, 2020 starts on a Sunday,
         * assumes weeks start on Sunday,
         * but is configurable via `firstDayOfWeek`.
         */
        const intl = new Intl.DateTimeFormat(locale, { weekday: 'short' });
        const startDate = new Date('11/01/2020');
        const daysOfWeek = [];
        /**
         * For each day of the week,
         * get the day name.
         */
        for (let i = firstDayOfWeek; i < firstDayOfWeek + 7; i++) {
            const currentDate = new Date(startDate);
            currentDate.setDate(currentDate.getDate() + i);
            const d = intl.format(currentDate);
            daysOfWeek.push(d.toUpperCase().startsWith('SA') ? d : d.slice(0, 2));
        }
        return daysOfWeek;
    }
    calculateDates() {
        const dates = [];
        const year = this.currentDate.getFullYear();
        const month = this.currentDate.getMonth();
        const date = new Date(year, month, 1);
        while (date.getMonth() === month) {
            dates.push(new Date(date));
            date.setDate(date.getDate() + 1);
        }
        this.currentMonthDates = dates;
    }
}

class ModusDatePickerState {
    constructor(el) {
        var _a;
        this.isOpen = false;
        this.element = el;
        this.element.showCalendarIcon = ((_a = this.element.showCalendarIcon) === null || _a === void 0 ? void 0 : _a.toString().toUpperCase()) !== 'FALSE';
        this.max = this.parseDate(this.element.max);
        this.min = this.parseDate(this.element.min);
        this.refresh();
    }
    getDate() {
        return this.date;
    }
    getMaxDateAllowed() {
        return this.max;
    }
    getMinDateAllowed() {
        return this.min;
    }
    setDate(val) {
        // Converting to ISO8601 'yyyy-mm-dd' format
        if (Number(val)) {
            const year = val.getFullYear();
            const month = (val.getMonth() + 1).toString().padStart(2, '0'); // Zero based number system for months
            const date = val.getDate().toString().padStart(2, '0');
            this.element.value = `${year}-${month}-${date}`;
            this.element.errorText = null;
            this.element.focusInput();
            this.date = val;
        }
    }
    setError(message = null) {
        this.element.errorText = message;
    }
    validateInput() {
        this.element.validate();
    }
    refresh() {
        this.date = this.parseDate(this.element.value);
    }
    parseDate(date) {
        if (!date) {
            return null;
        }
        // Note: Modus Date Input component's value is always in 'yyyy-mm-dd' format
        const dateISORegex = new RegExp(ISO_DATE_FORMAT);
        const parse = dateISORegex.exec(date);
        if (parse) {
            // first element returns the whole date string
            parse.shift();
            return new Date(parseFloat(parse[0]), parseFloat(parse[1]) - 1, // Zero based number system for months
            parseFloat(parse[2]));
        }
        return null;
    }
    toggleCalendar(val = null) {
        this.isOpen = val !== null ? val : !this.isOpen;
    }
    isCalendarOpen() {
        return this.isOpen;
    }
}

const modusDatePickerCss = "@import url(\"https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700\");.modus-date-picker{display:inline-flex;flex-direction:column;font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";position:relative;width:100%}.modus-date-picker .date-inputs{display:grid;grid-gap:0.5rem;grid-template-columns:auto auto}.modus-date-picker button{background:0;border:0;cursor:pointer;display:inline-flex;margin:0;padding:0}.modus-date-picker button.disabled{cursor:default}.modus-date-picker .label-container{display:flex}.modus-date-picker .label-container label{color:var(--modus-input-label-color, #464b52);font-size:0.75rem;margin-bottom:0.25rem}.modus-date-picker .input-container input{font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\"}.modus-date-picker .calendar-container{background-color:var(--modus-date-picker-calendar-body-bg, #fff);border-radius:4px;box-shadow:0 0 4px rgba(0, 0, 0, 0.1607843137);display:flex;flex-direction:column;font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";margin-top:0.15rem;position:absolute;z-index:1}.modus-date-picker .calendar-container .calendar-header{align-items:center;background-color:var(--modus-date-picker-calendar-header-bg, #0063a3);border-top-left-radius:4px;border-top-right-radius:4px;color:var(--modus-date-picker-calendar-header-color, #fff);display:flex;font:normal normal 600 16px/22px \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";height:40px;justify-content:space-around;letter-spacing:0;opacity:1;text-align:center;width:100%}.modus-date-picker .calendar-container .calendar-header svg path{fill:var(--modus-date-picker-calendar-header-color, #fff)}.modus-date-picker .calendar-container .calendar-header .title{align-items:center;display:inline-flex;justify-content:center}.modus-date-picker .calendar-container .calendar-header .calendar-title:focus+.year-icons,.modus-date-picker .calendar-container .calendar-header .calendar-title:hover+.year-icons,.modus-date-picker .calendar-container .calendar-header .calendar-title:active+.year-icons,.modus-date-picker .calendar-container .calendar-header .year-icons:hover,.modus-date-picker .calendar-container .calendar-header .year-icons:focus,.modus-date-picker .calendar-container .calendar-header .year-icons:focus-within{opacity:1 !important}.modus-date-picker .calendar-container .calendar-header .year-icons{display:inline-flex;flex-direction:column;margin-left:0.5rem;opacity:0}.modus-date-picker .calendar-container .calendar-header .year-icons button:active{opacity:0.5}.modus-date-picker .calendar-container .calendar-body{align-items:center;display:flex;flex-direction:column;font-size:0.875rem;justify-content:center;padding:1rem}.modus-date-picker .calendar-container .calendar-body .grid{display:grid;grid-template-columns:repeat(7, 1fr);text-align:center}.modus-date-picker .calendar-container .calendar-body .grid .grid-item{align-items:center;display:flex;height:32px;justify-content:center;width:32px}.modus-date-picker .calendar-container .calendar-body .out-of-range-notification{margin-top:0.6rem;text-align:center}.modus-date-picker .calendar-container .calendar-body .goto-available-dates{color:var(--modus-link-color, #217cbb);cursor:pointer}.modus-date-picker .calendar-container .calendar-body .calendar-days-week{color:var(--modus-date-picker-calendar-day-week-color, #363545);font:normal normal bold 14px/19px \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";letter-spacing:0;opacity:1;text-align:center}.modus-date-picker .calendar-container .calendar-body .calendar-day{color:var(--modus-date-picker-calendar-day-color, #252a2e);font:normal normal normal 14px/19px \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";letter-spacing:0;opacity:1;text-align:center}.modus-date-picker .calendar-container .calendar-body .calendar-day:hover{background:var(--modus-date-picker-calendar-day-hover-bg, #e0e1e9) 0% 0% no-repeat padding-box !important;border-radius:16px}.modus-date-picker .calendar-container .calendar-body .calendar-day.current-day{background:var(--modus-date-picker-calendar-body-bg, #fff) 0% 0% no-repeat padding-box;border:2px solid var(--modus-date-picker-calendar-day-current-border-color, #217cbb);border-radius:16px}.modus-date-picker .calendar-container .calendar-body .calendar-day.selected{background:var(--modus-date-picker-calendar-day-selected-bg, #217cbb) 0% 0% no-repeat padding-box;border-radius:16px;color:var(--modus-date-picker-calendar-day-selected-color, #fff)}.modus-date-picker .calendar-container .calendar-body .calendar-day.selected.start::after,.modus-date-picker .calendar-container .calendar-body .calendar-day.selected.end::after{background-color:var(--modus-date-picker-calendar-day-selected-range-bg, #dcedf9);content:\"\";height:32px;position:absolute;width:32px;z-index:-1}.modus-date-picker .calendar-container .calendar-body .calendar-day.selected.start::after{border-radius:50% 0 0 50% !important}.modus-date-picker .calendar-container .calendar-body .calendar-day.selected.end::after{border-radius:0 50% 50% 0 !important}.modus-date-picker .calendar-container .calendar-body .calendar-day.disabled{opacity:var(--modus-date-picker-calendar-day-disabled-opacity, 0.3);pointer-events:none}.modus-date-picker .calendar-container .calendar-body .calendar-day.range-selected{background:var(--modus-date-picker-calendar-day-selected-range-bg, #dcedf9) 0% 0% no-repeat padding-box}.modus-date-picker .calendar-container .calendar-body .calendar-day.range-selected:hover::before,.modus-date-picker .calendar-container .calendar-body .calendar-day.range-selected.current-day::before{background:var(--modus-date-picker-calendar-day-selected-range-bg, #dcedf9) 0% 0% no-repeat padding-box;content:\"\";height:32px;position:absolute;width:32px;z-index:-1}.modus-date-picker .calendar-container .calendar-body .calendar-month{position:absolute}.modus-date-picker .calendar-container .calendar-body .calendar-month.invalid-date-range .start::after,.modus-date-picker .calendar-container .calendar-body .calendar-month.invalid-date-range .end::after{opacity:0}.modus-date-picker .calendar-container .calendar-body .calendar-month-container{display:flex;height:180px;justify-content:center;position:relative}";
const ModusDatePickerStyle0 = modusDatePickerCss;

const ModusDatePicker = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this._dateInputs = {};
        this._locale = 'default';
        this.isInvalidDateRange = (startDate, endDate) => this.compare(endDate, startDate) < 0;
        this.label = undefined;
        this._forceUpdate = {};
        this._showCalendar = false;
        this._showYearArrows = false;
    }
    get _currentInput() {
        return Object.values(this._dateInputs).find((dt) => dt.isCalendarOpen());
    }
    componentWillLoad() {
        this._calendar = new ModusDatePickerCalendar();
    }
    /** Handlers */
    handleCalendarIconClick(event) {
        const { type } = event.detail;
        Object.keys(this._dateInputs).forEach((d) => this._dateInputs[d].toggleCalendar(d === type ? null : false));
        this.toggleCalendar();
        if (this._showCalendar) {
            this.gotoDateBeingPicked(this._dateInputs[type].getDate());
        }
        this.forceUpdate();
    }
    handleClickOutside(event) {
        if (this.element.contains(event.target) || event.defaultPrevented) {
            return;
        }
        // Collapse when clicked outside
        this.toggleCalendar(false);
    }
    handleDateInputValue(event) {
        const { type } = event.detail;
        if (!this._dateInputs[type])
            return;
        this._dateInputs[type].refresh();
        if (this._showCalendar) {
            this.gotoDateBeingPicked(this._dateInputs[type].getDate());
        }
        this.forceUpdate();
    }
    handleDateInputBlur() {
        var _a, _b;
        this.applyDateRangeRules((_a = this._dateInputs['start']) === null || _a === void 0 ? void 0 : _a.getDate(), (_b = this._dateInputs['end']) === null || _b === void 0 ? void 0 : _b.getDate());
    }
    handleSlotChange() {
        const dates = Array.from(this.element.querySelectorAll('modus-date-input'));
        dates === null || dates === void 0 ? void 0 : dates.forEach((d) => {
            this._dateInputs[d.type] = new ModusDatePickerState(d);
        });
    }
    /** Helpers */
    addMonthOffset(offset) {
        this._calendar.addMonthOffset(offset);
        this.forceUpdate();
    }
    addYearOffset(offset) {
        this._calendar.addYearOffset(offset);
        this.forceUpdate();
    }
    applyDateRangeRules(startDate, endDate) {
        if (!startDate || !endDate) {
            return;
        }
        if (this.isInvalidDateRange(startDate, endDate)) {
            this._dateInputs['start'].setError('Invalid date range');
            this._dateInputs['end'].setError();
        }
        else {
            this._dateInputs['start'].validateInput();
            this._dateInputs['end'].validateInput();
        }
    }
    compare(date1, date2) {
        if (!date1 && !date2) {
            return 0;
        }
        else if (!date1 && date2) {
            return -1;
        }
        else if (date1 && !date2) {
            return 1;
        }
        let delta;
        delta = date1.getFullYear() - date2.getFullYear();
        if (delta !== 0) {
            return delta;
        }
        delta = date1.getMonth() - date2.getMonth();
        if (delta !== 0) {
            return delta;
        }
        return date1.getDate() - date2.getDate();
    }
    forceUpdate() {
        this._forceUpdate = Object.assign({}, this._forceUpdate);
    }
    findDatePositionsInARange(date, startDate, endDate) {
        return {
            start: startDate && this.compare(date, startDate) === 0,
            end: endDate && this.compare(date, endDate) === 0,
            'in-range': startDate && endDate && this.compare(date, startDate) > 0 && this.compare(date, endDate) < 0,
        };
    }
    gotoDateBeingPicked(pickedDate) {
        if (!this._showCalendar) {
            return;
        }
        const date = pickedDate || new Date();
        this._calendar.gotoDate(date.getFullYear(), date.getMonth());
    }
    goToNearestBoundaryDate(date) {
        var _a, _b;
        const minDate = (_a = this._currentInput) === null || _a === void 0 ? void 0 : _a.getMinDateAllowed();
        const maxDate = (_b = this._currentInput) === null || _b === void 0 ? void 0 : _b.getMaxDateAllowed();
        const targetDate = this.compare(date, minDate) < 0 ? minDate : maxDate;
        this.gotoDateBeingPicked(targetDate);
        this.forceUpdate();
    }
    pickCalendarDate(date) {
        this._currentInput.setDate(date);
        this.toggleCalendar(false);
    }
    showYearChange(show = true) {
        this._showYearArrows = show;
    }
    isWithinCurrentMinMax(date) {
        var _a, _b;
        const max = (_a = this._currentInput) === null || _a === void 0 ? void 0 : _a.getMaxDateAllowed();
        const min = (_b = this._currentInput) === null || _b === void 0 ? void 0 : _b.getMinDateAllowed();
        if (!date) {
            return false;
        }
        if (min && this.compare(date, min) < 0) {
            return false;
        }
        if (max && this.compare(date, max) > 0) {
            return false;
        }
        return true;
    }
    toggleCalendar(val = null) {
        if (val !== null) {
            this._showCalendar = val;
            if (!this._showCalendar) {
                Object.keys(this._dateInputs || {}).forEach((d) => {
                    this._dateInputs[d].toggleCalendar(false);
                });
            }
        }
        else {
            this._showCalendar = !!Object.values(this._dateInputs).find((dt) => dt.isCalendarOpen());
        }
    }
    renderCalendarBody() {
        var _a, _b, _c, _d;
        const today = new Date();
        const startDate = (_a = this._dateInputs['start']) === null || _a === void 0 ? void 0 : _a.getDate();
        const endDate = (_b = this._dateInputs['end']) === null || _b === void 0 ? void 0 : _b.getDate();
        const singleDate = (_c = this._dateInputs['single']) === null || _c === void 0 ? void 0 : _c.getDate();
        // Get day of the week and prepare blank cells to render the calendar dates properly
        const firstDay = (_d = new Date(this._calendar.selectedYear, this._calendar.selectedMonth)) === null || _d === void 0 ? void 0 : _d.getDay();
        const blankDatesArr = new Array(firstDay).fill(0);
        return (h("div", { class: "calendar-body" }, h("div", { class: "calendar-days-week grid" }, this._calendar.getDaysOfWeek(this._locale).map((d) => {
            return h("div", { class: "grid-item" }, d);
        })), h("div", { class: "calendar-month-container" }, h("div", { class: {
                'calendar-month grid': true,
                'invalid-date-range': this.isInvalidDateRange(startDate, endDate),
            } }, blankDatesArr &&
            blankDatesArr.length > 0 &&
            blankDatesArr.map(() => {
                return (h("button", { class: {
                        'calendar-day grid-item': false,
                        disabled: true,
                    }, disabled: true, tabIndex: -1 }, "\u00A0"));
            }), this._calendar.dates.map((date, index) => {
            if (!date) {
                return null;
            }
            const positions = this.findDatePositionsInARange(date, startDate, endDate);
            const isStartDate = positions['start'];
            const isEndDate = positions['end'];
            const isToday = this.compare(date, today) === 0;
            const isSingleDateSelected = singleDate && this.compare(date, singleDate) === 0;
            const isSelected = isStartDate || isEndDate || isSingleDateSelected;
            const isInRange = !isSelected ? positions['in-range'] : false;
            const isDateDisabled = !this.isWithinCurrentMinMax(date);
            // Only for the last date in the calendar
            const onBlurEvent = index === this._calendar.dates.length - 1
                ? {
                    onBlur: () => {
                        this.toggleCalendar(false);
                    },
                }
                : {};
            return (h("button", Object.assign({ class: {
                    'calendar-day grid-item': true,
                    selected: isSelected,
                    disabled: isDateDisabled,
                    start: isStartDate && !isEndDate,
                    end: isEndDate && !isStartDate,
                    'current-day': isToday,
                    'range-selected': isInRange,
                }, disabled: isDateDisabled, tabIndex: 0, type: "button", "aria-current": isSelected ? 'date' : undefined, onClick: () => this.pickCalendarDate(date) }, onBlurEvent), date.getDate()));
        }))), !this.isWithinCurrentMinMax(this._currentInput.getDate()) && (h("div", { class: "out-of-range-notification" }, h("div", null, "The selected date is not available"), h("span", { class: "goto-available-dates", onClick: () => this.goToNearestBoundaryDate(this._currentInput.getDate()) }, "Go to available dates")))));
    }
    renderCalendarHeader() {
        var _a, _b;
        return (h("div", { class: "calendar-header" }, h("button", { type: "button", "aria-label": "Previous Month", onClick: () => this.addMonthOffset(-1) }, h(ModusIconMap, { icon: "chevron_left_bold" })), h("div", { class: "title" }, h("div", { class: "calendar-title", role: "heading" }, `${(_a = this._calendar) === null || _a === void 0 ? void 0 : _a.month} ${(_b = this._calendar) === null || _b === void 0 ? void 0 : _b.year}`), h("div", { class: "year-icons" }, h("button", { type: "button", tabIndex: 0, "aria-label": "Next Year", onClick: () => this.addYearOffset(1), class: "year-up" }, h(ModusIconMap, { icon: "caret_up", size: "16" })), h("button", { type: "button", tabIndex: 0, "aria-label": "Previous Year", onClick: () => this.addYearOffset(-1), class: "year-down" }, h(ModusIconMap, { size: "16", icon: "caret_down" })))), h("button", { type: "button", tabIndex: 0, "aria-label": "Next Month", onClick: () => this.addMonthOffset(1) }, h(ModusIconMap, { icon: "chevron_right_bold" }))));
    }
    render() {
        return (h("div", { key: '45ef27e63b41e4b08a1c084acfc0b9d9d92070e3', class: "modus-date-picker" }, this.label ? h("div", { class: 'label-container' }, this.label ? h("label", null, this.label) : null) : null, h("div", { key: '8db804f8291c99e8be8434d81491769b8e2ff604', class: "date-inputs", part: "date-inputs" }, h("slot", { key: 'b003c1220288f9aa056c1cabc4e17d0c20851631', onSlotchange: () => this.handleSlotChange() })), h("div", { key: '973e68544060a5c9bc74f15ef79e21815eee3ba7', style: { display: 'inline-flex' } }, this._showCalendar && (h("nav", { class: "calendar-container", "aria-label": "Pick a Date" }, this.renderCalendarHeader(), this.renderCalendarBody())))));
    }
    get element() { return getElement(this); }
};
ModusDatePicker.style = ModusDatePickerStyle0;

const modusNumberInputCss = "@import url(\"https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700\");.modus-number-input{display:inline-flex;flex-direction:column;font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";width:100%}.modus-number-input label{color:var(--modus-input-label-color, #464b52);font-size:0.75rem;font-weight:700;margin-bottom:0.25rem}.modus-number-input label span{color:var(--modus-input-border-color, #6a6e79);margin:0.25rem}.modus-number-input .label-container{align-items:baseline;display:inline-block;margin-bottom:0.25rem}.modus-number-input .label-container .required{color:var(--modus-input-validation-error-color, #da212c);margin-left:0.25rem}.modus-number-input .input-container{align-items:center;background-color:var(--modus-input-bg, #fff);border:0.0625rem solid var(--modus-input-border-color, #6a6e79);border-radius:4px;display:flex;flex-direction:row;height:32px}.modus-number-input .input-container input{background-color:transparent;border:none;color:var(--modus-input-color, #252a2e);font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";outline:0;padding:0 0.5rem;width:100%}.modus-number-input .input-container input.text-align-right{padding-right:0;text-align:right}.modus-number-input .input-container input::placeholder{color:var(--modus-input-hint-text-color, #a3a6b1)}.modus-number-input .input-container:focus-within{border-color:var(--modus-input-border-active-color, #217cbb);box-shadow:0 0 0 1px var(--modus-input-border-active-color, #217cbb)}.modus-number-input .input-container.error{border-color:var(--modus-input-validation-error-color, #da212c);box-shadow:0 0 0 1px var(--modus-input-validation-error-color, #da212c)}.modus-number-input .input-container.valid{border-color:var(--modus-input-validation-success-color, #006638);box-shadow:0 0 0 1px var(--modus-input-validation-success-color, #006638)}.modus-number-input .input-container.large{height:48px}.modus-number-input .input-container.large input{font-size:0.875rem;height:47px;padding:0 1rem}.modus-number-input .input-container:has(input[readonly]){background-color:var(--modus-input-readonly-bg, #e0e1e9);border-color:var(--modus-input-disabled-bottom-line-color, #a3a6b1)}.modus-number-input .sub-text{font-size:0.75rem;margin-top:0.25rem}.modus-number-input .sub-text.helper{color:var(--modus-input-label-color, #464b52);display:block;font-weight:600;margin:0}.modus-number-input .sub-text.error{color:var(--modus-input-validation-error-color, #da212c)}.modus-number-input .sub-text.valid{color:var(--modus-input-validation-success-color, #006638)}.modus-number-input.disabled{pointer-events:none}.modus-number-input.disabled .input-container{background-color:var(--modus-input-disabled-bg, #e0e1e9);border-color:transparent}.modus-number-input.disabled .input-container input{background-color:transparent;color:var(--modus-input-disabled-color, #a3a6b1)}";
const ModusNumberInputStyle0 = modusNumberInputCss;

const ModusNumberInput = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChange = createEvent(this, "valueChange", 7);
        this.inputId = generateElementId() + '_number-input';
        this.classBySize = new Map([
            ['medium', 'medium'],
            ['large', 'large'],
        ]);
        this.ariaLabel = undefined;
        this.disabled = undefined;
        this.errorText = undefined;
        this.helperText = undefined;
        this.label = undefined;
        this.maxValue = undefined;
        this.minValue = undefined;
        this.placeholder = undefined;
        this.readOnly = undefined;
        this.required = undefined;
        this.size = 'medium';
        this.step = undefined;
        this.textAlign = 'left';
        this.validText = undefined;
        this.value = undefined;
    }
    handleOnInput() {
        this.value = this.numberInput.value;
        this.valueChange.emit(this.value);
    }
    /** Focus the input. */
    async focusInput() {
        this.numberInput.focus();
    }
    watchValue(newValue, oldValue) {
        if (isNaN(+newValue)) {
            this.value = oldValue;
        }
        else {
            this.value = newValue;
        }
    }
    render() {
        var _a;
        const textAlignClassName = `text-align-${this.textAlign}`;
        const buildContainerClassNames = () => {
            const classNames = [];
            classNames.push('modus-number-input');
            if (this.disabled) {
                classNames.push('disabled');
            }
            return classNames.join(' ');
        };
        const buildInputContainerClassNames = () => {
            const classNames = [];
            classNames.push('input-container');
            classNames.push(this.classBySize.get(this.size));
            if (this.errorText) {
                classNames.push('error');
            }
            if (this.validText) {
                classNames.push('valid');
            }
            return classNames.join(' ');
        };
        return (h("div", { class: buildContainerClassNames() }, this.label || this.required ? (h("div", { class: "label-container" }, this.label ? h("label", { htmlFor: this.inputId }, this.label) : null, this.required ? h("span", { class: "required" }, "*") : null, this.helperText ? h("label", { class: "sub-text helper" }, this.helperText) : null)) : null, h("div", { class: buildInputContainerClassNames(), part: "input-container" }, h("input", { id: this.inputId, "aria-label": this.ariaLabel, "aria-invalid": !!this.errorText, "aria-required": (_a = this.required) === null || _a === void 0 ? void 0 : _a.toString(), "aria-valuemax": this.maxValue, "aria-valuemin": this.minValue, "aria-valuenow": this.value, class: textAlignClassName, disabled: this.disabled, max: this.maxValue, min: this.minValue, onInput: () => this.handleOnInput(), placeholder: this.placeholder, readonly: this.readOnly, ref: (el) => (this.numberInput = el), step: this.step, tabIndex: 0, type: "number", value: this.value })), this.errorText ? (h("label", { class: "sub-text error" }, this.errorText)) : this.validText ? (h("label", { class: "sub-text valid" }, this.validText)) : null));
    }
    static get watchers() { return {
        "value": ["watchValue"]
    }; }
};
ModusNumberInput.style = ModusNumberInputStyle0;

const modusSelectCss = "@import url(\"https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700\");:host{color:var(--modus-input-color, #252a2e);font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";position:relative}:host .label-container{align-items:baseline;display:flex}:host .label-container label{color:var(--modus-input-label-color, #464b52);font-size:0.75rem;font-weight:700;margin:0 0.25rem 0.25rem 0}:host .label-container .required{color:var(--modus-input-validation-error-color, #da212c)}:host .input-container{position:relative}:host .input-container:hover{cursor:pointer}:host .input-container select{align-items:center;appearance:none;background-color:var(--modus-input-bg, #fff);background-image:var(--modus-select-bg-image, url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\"%3e%3cpath fill=\"none\" stroke=\"%231b1a26\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"m2 5 6 6 6-6\"/%3e%3c/svg>'));background-position:right 0.5rem center;background-repeat:no-repeat;background-size:16px 12px;border:solid 0.0625rem var(--modus-input-border-color, #6a6e79);border-radius:4px;color:var(--modus-input-color, #464b52);display:flex;font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";font-size:0.75rem;height:2rem;padding-left:0.625rem;padding-right:2rem;position:relative;width:100%}:host .input-container select.disabled{background-color:var(--modus-input-disabled-bg, #e0e1e9);border-color:transparent}:host .input-container select:hover{cursor:pointer}:host .input-container select:focus{outline:none}:host .input-container select:focus-within{border-color:var(--modus-input-border-active-color, #217cbb);box-shadow:0 0 0 1px var(--modus-input-border-active-color, #217cbb)}:host .input-container select.large{font-size:0.875rem;height:3rem}:host .input-container select.error{border-color:var(--modus-input-validation-error-color, #da212c);box-shadow:0 0 0 1px var(--modus-input-validation-error-color, #da212c)}:host .input-container select.valid{border-color:var(--modus-input-validation-success-color, #006638);box-shadow:0 0 0 1px var(--modus-input-validation-success-color, #006638)}:host .input-container select.fit-parent{border:none;height:inherit}:host .sub-text{font-size:0.75rem;margin-top:0.25rem}:host .sub-text.helper{color:var(--modus-input-label-color, #464b52)}:host .sub-text.error{color:var(--modus-input-validation-error-color, #da212c)}:host .sub-text.valid{color:var(--modus-input-validation-success-color, #006638)}";
const ModusSelectStyle0 = modusSelectCss;

const ModusSelect = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChange = createEvent(this, "valueChange", 7);
        this.inputBlur = createEvent(this, "inputBlur", 7);
        this.selectId = generateElementId() + '_select';
        this.classBySize = new Map([
            ['medium', 'medium'],
            ['large', 'large'],
        ]);
        this.ariaLabel = undefined;
        this.disabled = undefined;
        this.errorText = undefined;
        this.helperText = undefined;
        this.label = undefined;
        this.options = [];
        this.optionsDisplayProp = undefined;
        this.placeholder = 'Please Select';
        this.required = undefined;
        this.size = 'medium';
        this.validText = undefined;
        this.value = undefined;
        this.internalValue = undefined;
        this.optionIdMap = new Map();
    }
    handleValueChange(newValue) {
        this.internalValue = newValue;
    }
    /** Focus the input. */
    async focusInput() {
        this.selectInput.focus();
    }
    connectedCallback() {
        this.internalValue = this.value;
    }
    handleOptionSelect(option) {
        this.valueChange.emit(option);
    }
    handleSelectChange(event) {
        const target = event.target;
        const selectedId = target.value;
        const option = this.optionIdMap.get(selectedId);
        this.handleOptionSelect(option);
    }
    renderSubText() {
        if (this.errorText) {
            return h("label", { class: "sub-text error" }, this.errorText);
        }
        else if (this.validText) {
            return h("label", { class: "sub-text valid" }, this.validText);
        }
        else if (this.helperText) {
            return h("label", { class: "sub-text helper" }, this.helperText);
        }
        return null;
    }
    renderLabel() {
        return this.label || this.required ? (h("div", { class: "label-container" }, this.label ? h("label", { htmlFor: this.selectId }, this.label) : null, this.required ? h("span", { class: "required" }, "*") : null)) : null;
    }
    renderOptions() {
        var _a;
        return (_a = this.options) === null || _a === void 0 ? void 0 : _a.map((option) => {
            const optionId = createGuid();
            this.optionIdMap.set(optionId, option);
            return (h("option", { value: optionId, key: optionId, selected: option === this.internalValue }, option[this.optionsDisplayProp]));
        });
    }
    render() {
        var _a;
        const selectClass = `${this.classBySize.get(this.size)} ${this.errorText ? 'error' : this.validText ? 'valid' : this.disabled ? 'disabled' : ''}`;
        return (h("div", { key: '7d7af883b684c5f73670fa3423d2e994c740627a', class: this.disabled ? 'disabled' : undefined }, this.renderLabel(), h("span", { key: '034f3f8ffe4f7b5fba92feb904ee94da4958d7ea', class: "input-container" }, h("select", { key: '7bdf01255ec7aa2ed756cd72f6b52b408e67b6e2', part: "input", ref: (el) => (this.selectInput = el), disabled: this.disabled, id: this.selectId, class: selectClass, "aria-label": this.ariaLabel || undefined, onBlur: (e) => this.inputBlur.emit(e), onChange: (event) => {
                this.handleSelectChange(event);
            }, "aria-invalid": !!this.errorText, "aria-required": (_a = this.required) === null || _a === void 0 ? void 0 : _a.toString() }, h("option", { key: '0911199be88ca56fb9ff1c063d9dede8c224c97a', value: "", disabled: true, selected: true }, this.placeholder), this.renderOptions()), this.renderSubText())));
    }
    static get watchers() { return {
        "value": ["handleValueChange"]
    }; }
};
ModusSelect.style = ModusSelectStyle0;

const modusTableCellEditorCss = "@import url(\"https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700\");:host{--modus-autocomplete-border:none;--modus-autocomplete-border-active:none;--modus-autocomplete-font-size:14px;--modus-input-border-color:none}.editor::part(input-container),.editor::part(input){height:2.9375rem !important}table.density-comfortable .editor::part(input-container),table.density-comfortable .editor::part(input){height:1.75rem !important}table.density-compact .editor::part(input-container),table.density-compact .editor::part(input){height:1.25rem !important}.autocomplete-container{margin-left:4px;margin-top:5px}.editor::part(sub-text){display:none}.date-picker-container::part(date-inputs){align-items:center;display:flex;justify-content:center}.editor::part(input-container){border:2px solid var(--modus-input-border-active-color, #217cbb);border-radius:unset;z-index:99}.editor::part(input-container error){border:2px solid var(--modus-input-validation-error-color, #da212c);border-radius:unset;z-index:99}.error-tooltip{background-color:var(--modus-input-validation-error-color, #da212c);border-radius:2px;color:#fff;display:none;font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";font-size:12px;font-weight:600;letter-spacing:0.005em;line-height:15px;max-width:200px;padding:5px 8px;text-align:left;word-wrap:break-word;z-index:10}";
const ModusTableCellEditorStyle0 = modusTableCellEditorCss;

var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const ModusTableCellEditor = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.handleBlur = () => {
            this.valueChange(this.editedValue);
            this.destroyErrorTooltip();
        };
        this.handleKeyDown = (e) => {
            this.keyDown(e, this.editedValue);
        };
        this.handleError = (e) => {
            this.errorMessage = e.detail;
            this.showErrorTooltip();
        };
        this.getDefaultProps = (ariaLabel) => ({
            'aria-label': ariaLabel,
            class: 'editor',
            ref: (ref) => (this.inputElement = ref),
        });
        this.args = undefined;
        this.dataType = undefined;
        this.value = undefined;
        this.type = undefined;
        this.valueChange = undefined;
        this.keyDown = undefined;
        this.errorMessage = undefined;
    }
    connectedCallback() {
        this.editedValue = this.value;
    }
    componentDidLoad() {
        if (this.inputElement['focusInput']) {
            this.inputElement['focusInput']();
        }
        this.createErrorTooltip();
    }
    disconnectedCallback() {
        this.destroyErrorTooltip();
    }
    handleDocumentClick(event) {
        if (this.type != 'date') {
            return;
        }
        const target = event.target;
        if (!this.inputElement.contains(target)) {
            this.handleBlur();
        }
    }
    createErrorTooltip() {
        if (!this.errorTooltip) {
            this.errorTooltip = document.createElement('div');
            this.errorTooltip.className = 'error-tooltip';
            this.inputElement.getRootNode().appendChild(this.errorTooltip); // Append to the same parent element as input
            this.popperInstance = createPopper(this.inputElement, this.errorTooltip, {
                placement: 'bottom-start',
                modifiers: [
                    {
                        name: 'offset',
                        options: {
                            offset: [-0.5, 0], // Offset from the element
                        },
                    },
                    {
                        name: 'preventOverflow',
                        options: {
                            boundary: 'viewport', // Prevents tooltip from overflowing the viewport
                        },
                    },
                ],
            });
        }
    }
    showErrorTooltip() {
        if (this.errorTooltip) {
            this.errorTooltip.innerText = this.errorMessage;
            this.errorTooltip.style.display = 'block';
            if (this.popperInstance) {
                this.popperInstance.update();
            }
        }
    }
    hideErrorTooltip() {
        if (this.errorTooltip) {
            this.errorTooltip.style.display = 'none';
        }
    }
    destroyErrorTooltip() {
        if (this.popperInstance) {
            this.popperInstance.destroy();
            this.popperInstance = null;
        }
        if (this.errorTooltip) {
            this.errorTooltip.remove();
            this.errorTooltip = null;
        }
    }
    renderNumberInput() {
        function handleArrowKeys(e, callback) {
            const code = e.key.toLowerCase();
            if (code === KEYBOARD_UP || code === KEYBOARD_DOWN) {
                e.stopPropagation();
            }
            else
                callback(e);
        }
        return (h("modus-number-input", Object.assign({}, this.getDefaultProps('Number input'), { value: this.value, textAlign: "right", size: "large", onBlur: this.handleBlur, onValueChange: (e) => (this.editedValue = e.detail), onKeyDown: (e) => handleArrowKeys(e, this.handleKeyDown) })));
    }
    renderTextInput() {
        return (h("modus-text-input", Object.assign({}, this.getDefaultProps('Text input'), { value: this.value, onValueChange: (e) => (this.editedValue = e.detail), onBlur: this.handleBlur, onKeyDown: this.handleKeyDown, autoFocusInput: true, size: "large" })));
    }
    renderSelectInput() {
        const valueKey = 'display';
        const args = this.args;
        const options = (args === null || args === void 0 ? void 0 : args.options) || [];
        const optionsDisplayProp = (args === null || args === void 0 ? void 0 : args.optionsDisplayProp) || valueKey;
        const placeholder = args === null || args === void 0 ? void 0 : args.placeholder;
        const selectedOption = options.find((option) => option[optionsDisplayProp] === this.value);
        function handleEnter(e, callback) {
            const code = e.key.toLowerCase();
            if (code === KEYBOARD_ENTER) {
                e.stopPropagation();
            }
            else
                callback(e);
        }
        return (h("div", null, h("modus-select", Object.assign({}, this.getDefaultProps('Select input'), { value: selectedOption, "options-display-prop": optionsDisplayProp, size: "large", options: options, placeholder: placeholder, onInputBlur: this.handleBlur, onKeyDown: (e) => handleEnter(e, this.handleKeyDown), onValueChange: (e) => {
                const detail = e.detail;
                if (this.dataType === 'badge') {
                    const { display } = detail, restProps = __rest(detail, ["display"]);
                    this.editedValue = Object.assign(Object.assign({}, restProps), { text: display });
                }
                else if (this.dataType === 'link') {
                    this.editedValue = detail;
                }
                else {
                    this.editedValue = detail[valueKey];
                }
            } }))));
    }
    renderDateInput() {
        var _a;
        const valueKey = 'value';
        const format = (_a = this.args) === null || _a === void 0 ? void 0 : _a.format;
        return (h("modus-date-picker", { onBlur: this.handleBlur, onClick: (e) => e.stopPropagation(), class: "date-picker-container" }, h("modus-date-input", Object.assign({}, this.getDefaultProps('Date input'), { format: format, size: "large", "show-calendar-icon": "true", value: this.value, onValueChange: (e) => {
                this.editedValue = e.detail[valueKey];
                this.hideErrorTooltip();
            }, onValueError: (e) => this.handleError(e) }))));
    }
    renderAutocompleteInput() {
        var _a, _b;
        const args = this.args;
        let options = [];
        let selectedOption = '';
        if (this.dataType === 'badge') {
            options = args === null || args === void 0 ? void 0 : args.options.map((option) => option.text);
            selectedOption = ((_a = this.value) === null || _a === void 0 ? void 0 : _a.text) || '';
        }
        else if (this.dataType === 'link') {
            options = args === null || args === void 0 ? void 0 : args.options.map((option) => option.display);
            selectedOption = ((_b = this.value) === null || _b === void 0 ? void 0 : _b.display) || '';
        }
        else {
            options = ((args === null || args === void 0 ? void 0 : args.options) || []);
            selectedOption = this.editedValue;
        }
        return (h("div", { class: "autocomplete-container" }, h("modus-autocomplete", Object.assign({}, this.getDefaultProps('Autocomplete input'), { "include-search-icon": "false", size: "medium", options: options, onBlur: this.handleBlur, onKeyDown: (e) => e.stopPropagation(), onOptionSelected: (e) => {
                const selectedDetail = e.detail;
                if (this.dataType === 'badge') {
                    const selectedOption = args === null || args === void 0 ? void 0 : args.options.find((option) => option.text === selectedDetail);
                    this.editedValue = selectedOption;
                }
                else if (this.dataType === 'link') {
                    const selectedOption = args === null || args === void 0 ? void 0 : args.options.find((option) => option.display === selectedDetail);
                    this.editedValue = selectedOption;
                }
                else {
                    this.editedValue = selectedDetail;
                }
            }, value: selectedOption }))));
    }
    renderEditor() {
        switch (this.type) {
            case CELL_EDIT_TYPE_SELECT:
                return this.renderSelectInput();
            case CELL_EDIT_TYPE_AUTOCOMPLETE:
                return this.renderAutocompleteInput();
            case CELL_EDIT_TYPE_DATE:
                return this.renderDateInput();
            case CELL_EDIT_TYPE_INT:
                return this.renderNumberInput();
            case CELL_EDIT_TYPE_TEXT:
            default:
                return this.renderTextInput();
        }
    }
    render() {
        return h(Host, { key: '27197918d3cbb8d084d13c51c3ec4be2ae27038d' }, this.renderEditor());
    }
};
ModusTableCellEditor.style = ModusTableCellEditorStyle0;

export { ModusAutocomplete as modus_autocomplete, ModusDateInput as modus_date_input, ModusDatePicker as modus_date_picker, ModusNumberInput as modus_number_input, ModusSelect as modus_select, ModusTableCellEditor as modus_table_cell_editor };
