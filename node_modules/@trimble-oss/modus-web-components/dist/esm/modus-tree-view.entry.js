import { h, r as registerInstance, c as createEvent, H as Host, g as getElement } from './index-8e730124.js';
import { T as TREE_ITEM_SIZE_CLASS } from './modus-content-tree.constants-b1c2cf71.js';

// eslint-disable-next-line @typescript-eslint/no-unused-vars
const ModusContentTreeDragItem = ({ draggingState, size, }) => {
    if (!draggingState)
        return null;
    const { width, translation, dragContent, validTarget, targetId } = draggingState;
    const dragContainerStyle = {
        width: width,
        transform: `translate(calc(${translation.x}px - 10%), calc(${translation.y}px - 50%))`,
        msTransform: `translateX(${translation.x}px) translateX(-10%) translateY(${translation.y}px) translateY(-50%)`,
    };
    const sizeClass = `${TREE_ITEM_SIZE_CLASS.get(size || 'standard')}`;
    const className = `drag-content${targetId && !validTarget ? ' drop-block' : ' drop-allow'} ${sizeClass}`;
    return h("div", { style: Object.assign({}, dragContainerStyle), ref: (el) => el && el.appendChild(dragContent), class: className });
};

const modusTreeViewCss = "@import url(\"https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700\");.drag-content{cursor:grabbing !important;left:0;opacity:0.9;position:fixed;top:0;z-index:99999}.drag-content .tree-item{align-items:center;background-color:var(--modus-tree-view-item-bg, #fff);border:0.0625rem solid var(--modus-tree-view-item-border-color, #e0e1e9);color:var(--modus-tree-view-item-color, #252a2e);display:flex;font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";font-size:1rem;height:2.375rem;width:100%}.drag-content .tree-item .icon-slot{visibility:hidden}.drag-content .tree-item.large{height:2.875rem}.drag-content .tree-item.small{font-size:0.75rem;height:1.875rem}.drag-content.drop-allow .tree-item{border:2px dashed var(--modus-tree-view-item-drag-border-color, #217cbb) !important}.drag-content.drop-block .tree-item{border:2px dashed var(--modus-tree-view-item-drag-error-border-color, #da212c) !important}:host{display:block}ul{padding:0}";
const ModusTreeViewStyle0 = modusTreeViewCss;

var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const ModusTreeView = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.itemDrop = createEvent(this, "itemDrop", 7);
        this.itemActionClick = createEvent(this, "itemActionClick", 7);
        this.items = {};
        this.syncItems = [];
        // local variables to avoid anonymous event listeners on document
        this.onMouseMove = (e) => this.handleItemDragOver(e);
        this.onMouseUp = () => this.handleItemDrop();
        this.onKeyDown = (e) => this.handleArrowKeys(e);
        this.INITIAL_DRAG_POSITION = { x: 0, y: 0 };
        this.checkboxSelection = undefined;
        this.checkedItems = [];
        this.disableTabbing = undefined;
        this.expandedItems = [];
        this.multiCheckboxSelection = undefined;
        this.multiSelection = undefined;
        this.selectedItems = [];
        this.size = 'standard';
        this.borderless = undefined;
        this.itemDragState = undefined;
        this.isDraggingWithKeyboard = undefined;
    }
    clearItemDropState() {
        if (!this.itemDragState)
            return null;
        const _a = this.itemDragState, { targetId } = _a, rest = __rest(_a, ["targetId"]);
        if (targetId) {
            this.items[targetId].content.classList.remove('drop-allow');
            this.items[targetId].content.classList.remove('drop-block');
        }
        return Object.assign(Object.assign({}, rest), { targetId: null, validTarget: null });
    }
    handleDocumentClick(event) {
        if (this.element.contains(event.target) || event.defaultPrevented)
            return;
        // Clear focus
        this.focusItem = null;
    }
    handleItemDragState(newValue, oldValue) {
        if (oldValue && newValue && oldValue.itemId === newValue.itemId)
            return;
        if (newValue) {
            document.addEventListener('mousemove', this.onMouseMove);
            document.addEventListener('mouseup', this.onMouseUp);
        }
        else {
            document.removeEventListener('mousemove', this.onMouseMove);
            document.removeEventListener('mouseup', this.onMouseUp);
        }
    }
    handleDraggingWithKeyboard(newValue) {
        if (newValue) {
            // add event listeners for arrow keys up and down
            document.addEventListener('keydown', this.onKeyDown);
        }
        else {
            document.removeEventListener('keydown', this.onKeyDown);
        }
    }
    handleItemDragStart(itemId, dragContent, event) {
        const { clientX, clientY, currentTarget } = event;
        const parent = currentTarget === null || currentTarget === void 0 ? void 0 : currentTarget.parentElement;
        const initialDragPosition = { x: clientX, y: clientY };
        this.clearItemDropState();
        this.itemDragState = {
            dragContent,
            origin: initialDragPosition,
            translation: initialDragPosition,
            itemId,
            width: `${parent === null || parent === void 0 ? void 0 : parent.offsetWidth}px`,
            height: `${parent === null || parent === void 0 ? void 0 : parent.offsetHeight}px`,
        };
    }
    handleItemDragStartKeyboard(itemId, dragContent, event) {
        if (event.code === 'Escape' && this.itemDragState) {
            dragContent.style.transform = `translate(${this.INITIAL_DRAG_POSITION.x}px, ${this.INITIAL_DRAG_POSITION.y}px)`;
            this.clearItemDropState();
            this.itemDragState = null;
        }
        if (event.code === 'Enter') {
            this.currentItem = null;
            if (!this.isDraggingWithKeyboard) {
                const { currentTarget } = event;
                const parent = currentTarget === null || currentTarget === void 0 ? void 0 : currentTarget.parentElement;
                const clientX = parent.getBoundingClientRect().x;
                const clientY = parent.getBoundingClientRect().y;
                const initialDragPosition = { x: clientX + 40, y: clientY + 20 };
                this.clearItemDropState();
                this.itemDragState = {
                    dragContent,
                    origin: initialDragPosition,
                    translation: initialDragPosition,
                    itemId,
                    width: `${parent === null || parent === void 0 ? void 0 : parent.offsetWidth}px`,
                    height: `${parent === null || parent === void 0 ? void 0 : parent.offsetHeight}px`,
                };
                this.isDraggingWithKeyboard = true;
            }
            else {
                // Perform dropping action
                this.handleItemDrop();
                this.isDraggingWithKeyboard = false;
            }
        }
    }
    handleKeys(direction, skipTwo = false) {
        if (direction === 1) {
            this.currentItem = this.items[this.getNextNavigableItem(this.currentItem.nodeId, skipTwo)];
        }
        else {
            this.currentItem = this.items[this.getPrevNavigableItem(this.currentItem.nodeId, skipTwo)];
        }
    }
    handleArrowKeys(event) {
        if (!this.itemDragState)
            return;
        const direction = event.key === 'ArrowUp' ? -1 : event.key === 'ArrowDown' ? 1 : 0;
        if (direction === 0)
            return;
        if (!this.currentItem) {
            this.currentItem = this.items[this.itemDragState.itemId];
        }
        this.handleKeys(direction);
        if (direction == 1) {
            if (this.currentItem == this.items[this.getNextNavigableItem(this.itemDragState.itemId)]) {
                this.handleKeys(direction);
            }
            if (this.currentItem == this.items[this.itemDragState.itemId]) {
                this.handleKeys(direction, true);
            }
        }
        else {
            if (this.currentItem == this.items[this.getNextNavigableItem(this.itemDragState.itemId)]) {
                this.handleKeys(direction, true);
            }
        }
        let newDragState = Object.assign({}, this.clearItemDropState());
        if (this.currentItem.nodeId && this.currentItem.nodeId !== newDragState.itemId) {
            const parents = this.getParentIds(this.currentItem.nodeId);
            newDragState = Object.assign(Object.assign({}, newDragState), { targetId: this.currentItem.nodeId });
            if (this.currentItem.element.droppableItem &&
                !this.isItemDisabled(this.currentItem.nodeId) &&
                !(parents && parents.includes(newDragState.itemId))) {
                newDragState.validTarget = true;
                this.currentItem.content.classList.add('drop-allow');
            }
            else {
                newDragState.validTarget = false;
                this.currentItem.content.classList.add('drop-block');
            }
        }
        // Update the itemDragState
        this.itemDragState = Object.assign({}, newDragState);
    }
    handleItemDragOver(event) {
        if (!this.itemDragState)
            return;
        const { clientX, clientY } = event;
        const translation = {
            x: clientX,
            y: clientY,
        };
        const { nodeId: dropZoneId, element: dropZoneItem, content: dropZoneContent, } = this.getItemWithinBounds(clientX, clientY) || {};
        let newDragState = Object.assign(Object.assign({}, this.clearItemDropState()), { translation });
        if (dropZoneId && dropZoneId !== newDragState.itemId) {
            const parents = this.getParentIds(dropZoneId);
            newDragState = Object.assign(Object.assign({}, newDragState), { targetId: dropZoneId });
            // avoid parent drag & drop over its children
            if (dropZoneItem.droppableItem &&
                !this.isItemDisabled(dropZoneId) &&
                !(parents && parents.includes(newDragState.itemId))) {
                newDragState.validTarget = true;
                dropZoneContent.classList.add('drop-allow');
            }
            else {
                newDragState.validTarget = false;
                dropZoneContent.classList.add('drop-block');
            }
        }
        this.itemDragState = Object.assign({}, newDragState);
    }
    handleItemDrop() {
        var _a;
        if (!this.itemDragState)
            return;
        const { itemId: dropItemId, targetId, validTarget } = this.itemDragState;
        if (dropItemId && validTarget && dropItemId !== targetId) {
            const { parentId, element } = this.items[targetId];
            if (element) {
                const insertAtParent = (((_a = this.items[parentId]) === null || _a === void 0 ? void 0 : _a.element) || this.element);
                const insertBefore = element;
                const insertElement = this.items[this.itemDragState.itemId].element;
                insertAtParent.insertBefore(insertElement, insertBefore);
                this.itemDrop.emit(this.items);
            }
        }
        this.clearItemDropState();
        this.itemDragState = null;
    }
    handleItemsProps(newValue, oldValue) {
        this.syncItems.push(...(oldValue || []), ...(newValue || []));
    }
    handleOptionsProps() {
        const options = this.getTreeViewItemOptions();
        Object.values(this.items).forEach(({ element }) => {
            element.initTreeViewItem(options);
        });
    }
    handleTreeSlotChange() {
        const childrenAtRoot = Array.from(this.element.children)
            .map((i) => i.nodeId)
            .filter((i) => i);
        childrenAtRoot.forEach((itemId, index) => {
            this.updateItem({ nodeId: itemId, index, parentId: null });
        });
    }
    getItemWithinBounds(x, y) {
        const node = Object.values(this.items).find(({ content }) => {
            const rect = content === null || content === void 0 ? void 0 : content.getBoundingClientRect();
            if (rect) {
                const inVerticalBounds = y >= rect.top && y <= rect.bottom;
                const inHorizontalBounds = x >= rect.left && x <= rect.right;
                return inVerticalBounds && inHorizontalBounds;
            }
            return false;
        });
        return node;
    }
    getParentIds(itemId) {
        if (!itemId)
            return [];
        const { parentId } = this.items[itemId];
        return parentId ? [parentId, ...this.getParentIds(parentId)] : [];
    }
    addItem(ele) {
        const treeItem = ele;
        const parent = ele.parentNode;
        if (treeItem.nodeId) {
            const { children: siblings, nodeId: parentId } = parent;
            const index = Array.from(siblings)
                .filter((i) => i.nodeId)
                .indexOf(treeItem);
            const level = this.getLevel(parentId) + 1;
            this.items[treeItem.nodeId] = Object.assign(Object.assign({}, this.items[treeItem.nodeId]), { nodeId: treeItem.nodeId, index, element: treeItem, disabled: treeItem.disabled, parentId,
                level });
            treeItem.initTreeViewItem(this.getTreeViewItemOptions());
        }
    }
    componentDidUpdate() {
        var _a;
        (_a = this.syncItems) === null || _a === void 0 ? void 0 : _a.forEach((i) => this.syncTreeViewItem(i));
        this.syncItems = [];
    }
    deleteItem(itemId) {
        const item = this.items[itemId];
        // eslint-disable-next-line prefer-const
        let deletedItems = [];
        if (item) {
            // remove children
            item.children.forEach((c) => {
                delete this.items[c];
                deletedItems.push(c);
            });
            // remove self
            delete this.items[itemId];
            deletedItems.push(itemId);
            // remove from API
            const removeFromAPI = (array) => {
                if (array.find((i) => deletedItems.includes(i)))
                    return array.filter((i) => !deletedItems.includes(i));
                return array;
            };
            this.checkedItems = removeFromAPI(this.checkedItems);
            this.selectedItems = removeFromAPI(this.selectedItems);
            this.expandedItems = removeFromAPI(this.expandedItems);
            // remove from locals
            if (deletedItems.includes(this.focusItem))
                this.focusItem = null;
        }
    }
    getChildrenIds(itemId, recursive = true) {
        var _a;
        const children = (_a = this.items[itemId]) === null || _a === void 0 ? void 0 : _a.children;
        if (!children)
            return [];
        return Array.from(children)
            .map((c) => this.items[c])
            .sort((a, b) => a.index - b.index)
            .reduce((r, c) => {
            r.push(c.nodeId, ...(recursive ? this.getChildrenIds(c.nodeId, recursive) : []));
            return r;
        }, []);
    }
    getLevel(itemId) {
        var _a;
        return ((_a = this.items[itemId]) === null || _a === void 0 ? void 0 : _a.level) || 0;
    }
    getFirstItem() {
        const item = this.element.firstElementChild;
        if (item) {
            return item.nodeId;
        }
        return null;
    }
    getLastItem() {
        const ele = this.element.lastElementChild;
        if (ele) {
            const lastItem = ele;
            let lastItemId = lastItem.nodeId;
            if (this.isItemExpanded(lastItem.nodeId)) {
                const children = this.getChildrenIds(lastItem.nodeId, true);
                lastItemId = children.slice(-1)[0];
            }
            return lastItemId;
        }
        return null;
    }
    getNavigableChildrenIds(parentId) {
        let siblings = [];
        if (parentId)
            siblings = this.getChildrenIds(parentId, false);
        else {
            siblings = Object.values(this.items)
                .filter((i) => !i.parentId)
                .sort((a, b) => a.index - b.index)
                .map((c) => c.nodeId);
        }
        return siblings.filter((c) => !this.isItemDisabled(c));
    }
    getNextNavigableItem(itemId, skipTwo = false) {
        // If expanded, get the first child
        if (this.isItemExpanded(itemId)) {
            const validItems = this.getNavigableChildrenIds(itemId);
            if (validItems.length)
                return validItems[0];
        }
        let item = this.items[itemId];
        while (item != null) {
            // Try to get the next sibling
            const siblings = this.getNavigableChildrenIds(item.parentId);
            const currentIndex = siblings.indexOf(item.nodeId);
            const nextIndex = skipTwo ? currentIndex + 2 : currentIndex + 1;
            const nextSibling = siblings[nextIndex];
            if (nextSibling) {
                return nextSibling;
            }
            // If the sibling does not exist, go up a level to the parent and try again
            item = this.items[item.parentId];
        }
        return itemId;
    }
    getPrevNavigableItem(itemId, skipTwo = false) {
        const item = this.items[itemId];
        const siblings = this.getNavigableChildrenIds(item.parentId);
        const index = siblings.indexOf(itemId);
        // Focus reached the top item
        if (index === 0) {
            return item.parentId || itemId;
        }
        // Get the previous item, if expanded get its last child
        let prevIndex = skipTwo ? index - 2 : index - 1;
        if (prevIndex < 0) {
            prevIndex = 0; // Ensure we don't go out of bounds
        }
        let curr = siblings[prevIndex];
        while (this.isItemExpanded(curr) && this.getNavigableChildrenIds(curr).length > 0) {
            curr = this.getNavigableChildrenIds(curr).pop();
        }
        return curr;
    }
    getTreeViewItemOptions() {
        return {
            multiSelection: this.multiSelection,
            checkboxSelection: this.checkboxSelection,
            multiCheckboxSelection: this.multiCheckboxSelection,
            size: this.size,
            borderless: this.borderless,
            disableTabbing: this.disableTabbing,
            getLevel: (id) => this.getLevel(id),
            hasItemFocus: (id) => this.isItemInFocus(id),
            hasItemSelected: (id) => this.isItemSelected(id),
            hasItemDisabled: (id) => this.isItemDisabled(id),
            hasItemExpanded: (id) => this.isItemExpanded(id),
            hasItemChecked: (id) => this.isItemChecked(id),
            hasItemIndeterminate: (id) => this.isItemIndeterminate(id),
            showSelectionIndicator: (id) => this.showSelectionIndicator(id),
            onItemSelection: (id, e) => this.handleItemSelection(id, e),
            onCheckboxSelection: (id, syncOnly) => this.handleCheckboxSelection(id, syncOnly),
            onItemExpandToggle: (id) => this.handleItemExpand(id),
            onItemFocus: (id) => this.handleItemFocus(id),
            onItemAdd: (ele) => this.addItem(ele),
            onItemDelete: (id) => this.deleteItem(id),
            onItemUpdate: (newValue, oldValue) => this.updateItem(newValue, oldValue),
            onItemDrag: (id, content, e) => this.handleItemDragStart(id, content, e),
            onItemDragClick: (id, content, e) => this.handleItemDragStartKeyboard(id, content, e),
        };
    }
    handleCheckboxSelection(currentId, syncOnly = false) {
        if (this.items[currentId].disabled)
            return;
        let currentChecked = !this.isItemChecked(currentId);
        let newCheckedItems = [...this.checkedItems];
        // eslint-disable-next-line prefer-const
        let itemsToSync = [...this.checkedItems, currentId];
        if (this.multiCheckboxSelection) {
            // update descendants
            if (syncOnly) {
                // syncOnly ensures no effect on the children checkboxes
                const descendants = this.getChildrenIds(currentId, false);
                const checked = descendants.filter((i) => newCheckedItems.includes(i));
                currentChecked = checked.length === descendants.length;
                if (currentChecked)
                    newCheckedItems.push(currentId);
                else
                    newCheckedItems = newCheckedItems.filter((i) => i !== currentId);
            }
            else {
                const descendants = this.getChildrenIds(currentId, true);
                if (currentChecked) {
                    newCheckedItems.push(currentId, ...descendants);
                }
                else
                    newCheckedItems = newCheckedItems.filter((i) => i !== currentId).filter((i) => !descendants.includes(i));
                itemsToSync.push(...descendants);
            }
            // update ancestors
            const ancestors = this.getParentIds(currentId);
            ancestors.forEach((id) => {
                const children = this.getChildrenIds(id, false);
                const checked = children.filter((i) => newCheckedItems.includes(i));
                const isChecked = checked.length === children.length;
                if (isChecked)
                    newCheckedItems.push(id);
                else
                    newCheckedItems = newCheckedItems.filter((i) => i !== id);
            });
            // items to be synced
            itemsToSync.push(...ancestors);
        }
        else {
            newCheckedItems = currentChecked ? [currentId] : [];
        }
        this.checkedItems = [...newCheckedItems];
        this.syncItems.push(...itemsToSync, ...newCheckedItems);
    }
    handleItemAdded(event) {
        this.addItem(event.detail);
        event.preventDefault();
        event.stopPropagation();
    }
    handleItemClick(event) {
        const actionId = event.detail.actionId;
        const nodeId = event.target.getAttribute('node-id');
        this.itemActionClick.emit({ actionId, nodeId });
    }
    handleItemExpand(itemId) {
        const { children } = this.items[itemId];
        if (!(children && children.length))
            return;
        const isExpanded = !this.isItemExpanded(itemId);
        let newExpandedItems = [...this.expandedItems];
        if (isExpanded)
            newExpandedItems.push(itemId);
        else
            newExpandedItems = newExpandedItems.filter((i) => i !== itemId);
        this.expandedItems = [...newExpandedItems];
        this.syncItems.push(itemId);
    }
    handleItemFocus(itemId) {
        const { element: current } = this.items[itemId];
        this.focusItem = itemId;
        current.focusItem();
    }
    handleItemSelection(itemId, event) {
        if (this.items[itemId].disabled)
            return;
        const allowMultipleSelection = this.multiSelection && event && (event.shiftKey || event.ctrlKey || event.metaKey);
        const isSelected = !this.isItemSelected(itemId);
        const oldItems = [...this.selectedItems];
        let newItems = [...this.selectedItems];
        if (isSelected) {
            if (allowMultipleSelection) {
                newItems.push(itemId);
            }
            else {
                newItems = [itemId];
            }
        }
        else {
            newItems = newItems.filter((i) => i !== itemId);
        }
        this.selectedItems = [...newItems];
        this.syncItems.push(...oldItems, ...newItems);
    }
    handleKeyDown(event) {
        if (event.defaultPrevented || event.altKey) {
            return; // Do nothing if event already handled or alt key pressed
        }
        const key = event.code.toUpperCase();
        let preventDefault = false;
        if (!this.isDraggingWithKeyboard) {
            switch (key) {
                case 'SPACE':
                    if (this.focusItem) {
                        this.handleItemExpand(this.focusItem);
                        preventDefault = true;
                    }
                    break;
                case 'ENTER':
                    if (this.focusItem) {
                        this.handleItemSelection(this.focusItem, event);
                        event.stopPropagation();
                    }
                    break;
                case 'ARROWDOWN':
                    // eslint-disable-next-line no-case-declarations
                    const nextItem = this.focusItem ? this.getNextNavigableItem(this.focusItem) : this.getFirstItem();
                    // Multi-Selection
                    if (this.multiSelection && event.shiftKey && this.isItemSelected(this.focusItem)) {
                        // deselect if going back to the selected node
                        if (this.isItemSelected(nextItem))
                            this.handleItemSelection(this.focusItem, event);
                        else
                            this.handleItemSelection(nextItem, event);
                    }
                    this.handleItemFocus(nextItem);
                    preventDefault = true;
                    break;
                case 'ARROWUP':
                    // eslint-disable-next-line no-case-declarations
                    const prevItem = this.focusItem ? this.getPrevNavigableItem(this.focusItem) : this.getLastItem();
                    // Multi-Selection
                    if (this.multiSelection && event.shiftKey && this.isItemSelected(this.focusItem)) {
                        // deselect if going back to the selected node
                        if (this.isItemSelected(prevItem))
                            this.handleItemSelection(this.focusItem, event);
                        else
                            this.handleItemSelection(prevItem, event);
                    }
                    this.handleItemFocus(prevItem);
                    preventDefault = true;
                    break;
                case 'ARROWRIGHT':
                    if (this.focusItem) {
                        if (this.disableTabbing && event.shiftKey) {
                            const { element } = this.items[this.focusItem];
                            element.focusCheckbox();
                        }
                        else if (!this.isItemExpanded(this.focusItem)) {
                            this.handleItemExpand(this.focusItem);
                        }
                    }
                    break;
                case 'ARROWLEFT':
                    if (this.focusItem && this.isItemExpanded(this.focusItem)) {
                        this.handleItemExpand(this.focusItem);
                    }
                    break;
                case 'TAB':
                    if (this.disableTabbing)
                        this.resetFocusItem();
                    break;
            }
        }
        if (preventDefault) {
            event.preventDefault();
            event.stopPropagation();
        }
    }
    isItemChecked(itemId) {
        return this.checkedItems.includes(itemId);
    }
    isItemExpanded(itemId) {
        return this.expandedItems.includes(itemId);
    }
    isItemInFocus(itemId) {
        return this.focusItem === itemId;
    }
    isItemSelected(itemId) {
        return this.selectedItems.includes(itemId);
    }
    isItemIndeterminate(itemId) {
        const children = this.getChildrenIds(itemId);
        if (children && this.multiCheckboxSelection) {
            const checked = children.filter((c) => this.isItemChecked(c));
            return checked.length > 0 && checked.length < children.length;
        }
        return false;
    }
    isItemDisabled(itemId) {
        const { disabled } = this.items[itemId];
        const parents = this.getParentIds(itemId);
        return disabled || Boolean(parents === null || parents === void 0 ? void 0 : parents.find((p) => this.items[p].disabled));
    }
    resetFocusItem() {
        this.focusItem = null;
    }
    showSelectionIndicator(itemId) {
        return (this.isItemSelected(itemId) ||
            (!this.isItemExpanded(itemId) && Boolean(this.getChildrenIds(itemId, true).find((i) => this.isItemSelected(i)))));
    }
    syncTreeViewItem(itemId) {
        var _a, _b;
        (_b = (_a = this.items[itemId]) === null || _a === void 0 ? void 0 : _a.element) === null || _b === void 0 ? void 0 : _b.updateComponent();
    }
    updateItem(newValue, oldValue) {
        var _a;
        let existing;
        // if nodeId was updated
        if (oldValue && newValue.nodeId !== oldValue.nodeId) {
            existing = Object.assign({}, this.items[oldValue.nodeId]);
            delete this.items[oldValue.nodeId];
        }
        else
            existing = Object.assign({}, this.items[newValue.nodeId]);
        // if the item exist
        if (existing.nodeId) {
            this.items[newValue.nodeId] = Object.assign(Object.assign({}, existing), newValue);
            (_a = newValue.children) === null || _a === void 0 ? void 0 : _a.forEach((i) => {
                const item = this.items[i];
                this.items[i] = Object.assign(Object.assign({}, item), { parentId: newValue.nodeId });
            });
        }
        else
            this.items[newValue.nodeId] = Object.assign({}, newValue);
    }
    render() {
        return (h(Host, { key: '66babb70ff1b7fb4ee1c9d1bbff24fb2cd4b31dc' }, h("ul", { key: '60012ff7564d2d73dfebfd94fc998827a0ea6187', role: "tree", tabindex: this.disableTabbing ? 0 : null, onKeyDown: (e) => this.handleKeyDown(e) }, h("slot", { key: 'ac0971a2f22edf9fb65d197c7a7313b16fcb6d23', onSlotchange: () => this.handleTreeSlotChange() })), h(ModusContentTreeDragItem, { key: 'f68ae591618566c112a788215ea4027a3f471ec0', draggingState: this.itemDragState }, h("div", { key: '39a3842b2993fff40a5b224eb7646938e7dfc44f', class: "drag-indicator", tabIndex: -1 }))));
    }
    get element() { return getElement(this); }
    static get watchers() { return {
        "itemDragState": ["handleItemDragState"],
        "isDraggingWithKeyboard": ["handleDraggingWithKeyboard"],
        "expandedItems": ["handleItemsProps"],
        "selectedItems": ["handleItemsProps"],
        "checkedItems": ["handleItemsProps"],
        "checkboxSelection": ["handleOptionsProps"],
        "disableTabbing": ["handleOptionsProps"],
        "multiCheckboxSelection": ["handleOptionsProps"],
        "multiSelection": ["handleOptionsProps"],
        "size": ["handleOptionsProps"],
        "borderless": ["handleOptionsProps"]
    }; }
};
ModusTreeView.style = ModusTreeViewStyle0;

export { ModusTreeView as modus_tree_view };
