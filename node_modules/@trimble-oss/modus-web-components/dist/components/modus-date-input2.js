import { proxyCustomElement, HTMLElement, createEvent, h } from '@stencil/core/internal/client';
import { M as ModusIconMap } from './ModusIconMap.js';
import { D as DateInputFormatter } from './modus-date-input.formatter.js';

const modusDateInputCss = "@import url(\"https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700\");.modus-date-input{box-sizing:border-box;display:inline-flex;flex-direction:column;font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";position:relative;width:100%}.modus-date-input button{background:0;border:0;cursor:pointer;margin:0;padding:0}.modus-date-input label{color:var(--modus-input-label-color, #464b52);font-size:0.75rem;font-weight:700;margin-bottom:0.25rem}.modus-date-input label span{color:var(--modus-input-border-color, #6a6e79);margin:0.25rem}.modus-date-input .label-container{display:flex}.modus-date-input .label-container .required{bottom:0.0625rem;color:var(--modus-input-validation-error-color, #da212c);margin-left:0.25rem;position:relative}.modus-date-input .input-container{align-items:center;background-color:var(--modus-input-bg, #fff);border:0.0625rem solid var(--modus-input-border-color, #6a6e79);border-radius:4px;box-sizing:border-box;display:flex;flex-direction:row;height:2rem;position:relative;width:100%}.modus-date-input .input-container input{background-color:transparent;border:none;color:var(--modus-input-color, #252a2e);font-size:0.75rem;outline:none;padding:0 0.5rem;width:100%}.modus-date-input .input-container input.has-right-icon{padding-right:0}.modus-date-input .input-container input::placeholder{color:var(--modus-input-hint-text-color, #a3a6b1)}.modus-date-input .input-container .icons{align-items:center;background-color:var(--modus-input-bg, #fff);border-bottom-right-radius:4px;border-top-right-radius:4px;display:flex;font-size:1rem;height:100%;justify-content:center;width:2rem}.modus-date-input .input-container .icons svg.icon-calendar{cursor:pointer !important;padding:0 0.375rem}.modus-date-input .input-container .icons svg.icon-calendar path{fill:var(--modus-date-input-calendar-icon-color, #6a6e79)}.modus-date-input .input-container:hover{cursor:text}.modus-date-input .input-container:focus-within{border-color:var(--modus-input-border-active-color, #217cbb);box-shadow:0 0 0 1px var(--modus-input-border-active-color, #217cbb)}.modus-date-input .input-container:focus-within svg.icon-calendar path{fill:var(--modus-input-border-active-color, #217cbb)}.modus-date-input .input-container.error{border-color:var(--modus-input-validation-error-color, #da212c);box-shadow:0 0 0 1px var(--modus-input-validation-error-color, #da212c)}.modus-date-input .input-container.error svg.icon-calendar path{fill:var(--modus-input-validation-error-color, #da212c)}.modus-date-input .input-container.valid{border-color:var(--modus-input-validation-success-color, #006638);box-shadow:0 0 0 1px var(--modus-input-validation-success-color, #006638)}.modus-date-input .input-container.valid svg.icon-calendar path{fill:var(--modus-input-validation-success-color, #006638)}.modus-date-input .input-container.large{height:3rem}.modus-date-input .input-container.large input{font-size:0.875rem;padding:0 1rem}.modus-date-input .input-container:has(input[readonly]){background-color:var(--modus-input-readonly-bg, #e0e1e9);border-color:transparent}.modus-date-input .sub-text{font-size:0.75rem}.modus-date-input .sub-text:has(label){margin-top:0.25rem}.modus-date-input .sub-text .helper{color:var(--modus-input-label-color, #464b52);display:block;font-weight:600;margin:0}.modus-date-input .sub-text .error{color:var(--modus-input-validation-error-color, #da212c)}.modus-date-input .sub-text .valid{color:var(--modus-input-validation-success-color, #006638)}.modus-date-input span.required{color:var(--modus-input-validation-error-color, #da212c)}.modus-date-input.large{font-size:0.875rem;height:48px}.modus-date-input.disabled{pointer-events:none}.modus-date-input.disabled .input-container{background-color:var(--modus-input-disabled-bg, #e0e1e9);border-color:transparent}.modus-date-input.disabled .input-container svg path{fill:var(--modus-input-disabled-color, #a3a6b1)}.modus-date-input.disabled .input-container .icons{background-color:var(--modus-input-disabled-bg, #e0e1e9);cursor:default}.modus-date-input.disabled .input-container input{background-color:transparent;border-radius:0;color:var(--modus-input-disabled-color, #a3a6b1);height:100%}.modus-date-input input{background-position:right calc(0.375em + 0.1875rem) center;background-repeat:no-repeat;background-size:calc(0.75em + 0.375rem) calc(0.75em + 0.375rem);font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";padding-right:calc(1.5em + 0.75rem)}";
const ModusDateInputStyle0 = modusDateInputCss;

const ModusDateInput = /*@__PURE__*/ proxyCustomElement(class ModusDateInput extends HTMLElement {
    constructor() {
        super();
        this.__registerHost();
        this.__attachShadow();
        this.calendarIconClicked = createEvent(this, "calendarIconClicked", 7);
        this.dateInputBlur = createEvent(this, "dateInputBlur", 7);
        this.valueChange = createEvent(this, "valueChange", 7);
        this.valueError = createEvent(this, "valueError", 7);
        this.classBySize = new Map([
            ['medium', 'medium'],
            ['large', 'large'],
        ]);
        this._dateInputId = `date-input-${Math.random().toString().slice(2, 7)}`;
        this._altFormatters = [];
        // TODO: Auto formatting for single tokens 'm' and 'd' is tricky because user can input double digits
        this.autoFormat = false;
        this.allowedCharsRegex = undefined;
        this.ariaLabel = undefined;
        this.autoFocusInput = undefined;
        this.disabled = undefined;
        this.disableValidation = undefined;
        this.errorText = undefined;
        this.fillerDate = undefined;
        this.format = 'mm/dd/yyyy';
        this.altFormats = undefined;
        this.helperText = undefined;
        this.label = undefined;
        this.placeholder = undefined;
        this.readOnly = undefined;
        this.required = undefined;
        this.showCalendarIcon = undefined;
        this.size = 'medium';
        this.type = 'single';
        this.validText = undefined;
        this.min = undefined;
        this.max = undefined;
        this.value = undefined;
        this._dateDisplay = undefined;
    }
    handleFillerDateChange(val) {
        this._formatter = new DateInputFormatter(val, this.format);
    }
    handleFormatChange(val) {
        this._formatter = new DateInputFormatter(this.fillerDate, val);
        this.handleValueChange(this.value);
    }
    handleAltFormatsChange(altFormats) {
        if (!altFormats) {
            return;
        }
        this._altFormatters = altFormats
            .split('|')
            .map((format) => format.trim())
            .filter(Boolean)
            .map((format) => new DateInputFormatter(this.fillerDate, format));
    }
    handleValueChange(val) {
        if (!this._isEditing) {
            this._dateDisplay = this._formatter.formatDisplayString(val);
        }
        this.valueChange.emit({
            value: val,
            type: this.type,
            inputString: this._dateDisplay,
        });
    }
    componentWillLoad() {
        this.handleFormatChange(this.format);
        this.handleAltFormatsChange(this.altFormats);
        this._dateDisplay = this._formatter.formatDisplayString(this.value);
        this.setDefaultAllowedKeysRegex(this.autoFormat);
    }
    /** Methods */
    /** Focus the input. */
    async focusInput() {
        this._dateInput.focus();
    }
    /** Validate the input. */
    async validate() {
        this.validateInput(this._dateDisplay);
    }
    /** Handlers */
    handleCalendarClick() {
        this.calendarIconClicked.emit({
            value: this.value,
            type: this.type,
            inputString: this._dateDisplay,
        });
    }
    handleDefaultKeyDown(e, callback) {
        const code = e.code.toUpperCase();
        if (code === 'ENTER' || code === 'SPACE')
            callback();
    }
    handleBlur() {
        this._isEditing = false;
        this.updateDateFromAltFormats();
        this.validateInput(this._dateDisplay);
        this.dateInputBlur.emit({
            value: this.value,
            type: this.type,
            inputString: this._dateDisplay,
        });
    }
    handleInputKeyPress(event) {
        const keyIsValid = this.keyIsValidDateCharacter(event.key);
        if (!keyIsValid) {
            event.preventDefault();
        }
        return keyIsValid;
    }
    handleInputKeyDown(event) {
        if (event.key.toLowerCase() === 'enter') {
            this.handleBlur();
        }
    }
    handleOnInput(event) {
        var _a;
        this._isEditing = true;
        event.stopPropagation();
        event.preventDefault();
        const inputString = (_a = event.currentTarget) === null || _a === void 0 ? void 0 : _a.value;
        this._dateDisplay = inputString;
        this.value = this._formatter.parseDisplayString(inputString.trim());
    }
    // Helpers
    clearValidation() {
        this.errorText = null;
    }
    /** Check if the input string matches any of the alternative formats. */
    updateDateFromAltFormats() {
        if (this.value) {
            this._dateDisplay = this._formatter.formatDisplayString(this.value);
            return;
        }
        if (!this._dateDisplay)
            return;
        const displayDate = this._dateDisplay.trim();
        // if there is no value for the default format, check the alternative formats
        for (const formatter of this._altFormatters) {
            const result = formatter.parseDisplayString(displayDate);
            if (result) {
                this._dateDisplay = this._formatter.formatDisplayString(result);
                this.value = result;
                return;
            }
        }
    }
    keyIsValidDateCharacter(key) {
        if (!this.allowedCharsRegex)
            return true;
        const dateCharacterRegex = new RegExp(this.allowedCharsRegex);
        return dateCharacterRegex.test(key);
    }
    setDefaultAllowedKeysRegex(autoFormat) {
        if (!this.allowedCharsRegex) {
            this.allowedCharsRegex = autoFormat ? /\d/gi : /.*/;
        }
    }
    validateInput(inputString) {
        if (this.disableValidation)
            return;
        if (!inputString) {
            if (this.required) {
                this.errorText = 'Required';
                this.valueError.emit(this.errorText);
            }
            else {
                this.clearValidation();
            }
        }
        else if (!this.value) {
            this.errorText = 'Invalid date';
            this.valueError.emit(this.errorText);
        }
        else {
            this.validateMinMax();
        }
    }
    validateMinMax() {
        const min = this._formatter.parseIsoToDate(this.min);
        const max = this._formatter.parseIsoToDate(this.max);
        const value = this._formatter.parseIsoToDate(this.value);
        if (min && min > value) {
            min.setUTCDate(min.getDate() - 1);
            this.errorText = `Select a date after ${this._formatter.formatDisplayString(min.toISOString())}`;
            this.valueError.emit(this.errorText);
        }
        else if (max && max < value) {
            max.setUTCDate(max.getDate() + 1);
            this.errorText = `Select a date before ${this._formatter.formatDisplayString(max.toISOString())}`;
            this.valueError.emit(this.errorText);
        }
        else {
            this.clearValidation();
        }
    }
    render() {
        var _a;
        const className = `modus-date-input ${this.disabled ? 'disabled' : ''}`;
        return (h("div", { key: 'bf68b3a862d5ac7dafaf157720b5a6c6d0c0b0b2', class: className }, this.label || this.required ? (h("div", { class: "label-container" }, this.label ? h("label", { htmlFor: this._dateInputId }, this.label) : null, this.required ? h("span", { class: "required" }, "*") : null, this.helperText ? h("label", { class: "sub-text helper" }, this.helperText) : null)) : null, h("div", { key: 'ab7291ae18d2e9b83930142fff070068fbc49b01', class: `input-container ${this.errorText ? 'error' : this.validText ? 'valid' : ''} ${this.classBySize.get(this.size)}`, part: `input-container ${this.errorText ? 'error' : this.validText ? 'valid' : ''}` }, h("input", { key: 'a6cfc3cf6dc78f1a76d65635ec34ccecf96ddd36', "aria-invalid": !!this.errorText, "aria-label": this.ariaLabel || undefined, "aria-required": (_a = this.required) === null || _a === void 0 ? void 0 : _a.toString(), autofocus: this.autoFocusInput, class: { 'has-right-icon': this.showCalendarIcon }, disabled: this.disabled, id: this._dateInputId, onBlur: () => this.handleBlur(), onInput: (event) => this.handleOnInput(event), onKeyPress: (e) => this.handleInputKeyPress(e), onKeyDown: (e) => this.handleInputKeyDown(e), placeholder: this.placeholder, readonly: this.readOnly, ref: (el) => (this._dateInput = el), tabIndex: 0, type: "text", value: this._dateDisplay }), this.showCalendarIcon && (h("span", { class: "icons", tabIndex: 0, onKeyDown: (e) => this.handleDefaultKeyDown(e, () => this.handleCalendarClick()), onClick: () => this.handleCalendarClick(), role: "button", "aria-label": "Open calendar" }, h(ModusIconMap, { icon: "calendar", size: "16" })))), h("div", { key: '97083a2b1e4c71cb48a98b7e4d6ff2b714378730', class: "sub-text", part: "sub-text" }, this.errorText ? (h("label", { class: "error" }, this.errorText)) : this.validText ? (h("label", { class: "valid" }, this.validText)) : null)));
    }
    get element() { return this; }
    static get watchers() { return {
        "fillerDate": ["handleFillerDateChange"],
        "format": ["handleFormatChange"],
        "altFormats": ["handleAltFormatsChange"],
        "value": ["handleValueChange"]
    }; }
    static get style() { return ModusDateInputStyle0; }
}, [1, "modus-date-input", {
        "allowedCharsRegex": [1025, "allowed-chars-regex"],
        "ariaLabel": [1, "aria-label"],
        "autoFocusInput": [4, "auto-focus-input"],
        "disabled": [4],
        "disableValidation": [4, "disable-validation"],
        "errorText": [1, "error-text"],
        "fillerDate": [1, "filler-date"],
        "format": [1],
        "altFormats": [1, "alt-formats"],
        "helperText": [1, "helper-text"],
        "label": [1],
        "placeholder": [1],
        "readOnly": [4, "read-only"],
        "required": [4],
        "showCalendarIcon": [4, "show-calendar-icon"],
        "size": [1],
        "type": [1],
        "validText": [1, "valid-text"],
        "min": [1],
        "max": [1],
        "value": [1025],
        "_dateDisplay": [32],
        "focusInput": [64],
        "validate": [64]
    }, undefined, {
        "fillerDate": ["handleFillerDateChange"],
        "format": ["handleFormatChange"],
        "altFormats": ["handleAltFormatsChange"],
        "value": ["handleValueChange"]
    }]);
function defineCustomElement() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = ["modus-date-input"];
    components.forEach(tagName => { switch (tagName) {
        case "modus-date-input":
            if (!customElements.get(tagName)) {
                customElements.define(tagName, ModusDateInput);
            }
            break;
    } });
}

export { ModusDateInput as M, defineCustomElement as d };
