import { h, proxyCustomElement, HTMLElement, createEvent } from '@stencil/core/internal/client';
import { a as IconChevronLeft } from './IconChevronRight.js';
import { d as defineCustomElement$3 } from './modus-side-navigation-item2.js';
import { d as defineCustomElement$2 } from './modus-tooltip2.js';

// eslint-disable-next-line
const ModusSideNavigationTree = ({ data, itemSelected, tabIndex }) => {
    if (!(data === null || data === void 0 ? void 0 : data.length))
        return null;
    return data === null || data === void 0 ? void 0 : data.map(({ id, disabled, selected, label, menuIcon, children, onSideNavItemClicked, options }) => {
        const props = options ? Object.fromEntries(options) : {};
        const defaults = (children === null || children === void 0 ? void 0 : children.length) ? { showExpandIcon: true, disableSelection: true } : {};
        return (h("modus-side-navigation-item", Object.assign({ id: id, disabled: disabled, selected: selected || itemSelected === id, label: label, menuIcon: menuIcon, onSideNavItemClicked: (e) => onSideNavItemClicked && onSideNavItemClicked(e) }, defaults, { tabIndex: tabIndex }, props)));
    });
};

const modusSideNavigationCss = "@import url(\"https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700\");:host{display:block}.side-nav-panel{background-color:var(--modus-side-navigation-bg, #fff);box-shadow:1px 0 4px rgba(36, 35, 45, 0.3);height:100%;min-width:4rem !important;position:absolute;transition:all 0.2s ease-out 0s;width:4rem;z-index:1029}.side-nav-panel.expanded{overflow:hidden;transition:all 0.25s ease-in 0s !important;width:16rem}.side-nav-panel:not(.expanded) .side-nav-level:not(.center){display:none}.side-nav-panel .side-nav-level{position:absolute;transition:all 0.4s linear 0s;width:100%}.side-nav-panel .side-nav-level:not(.center){opacity:0;transition-duration:0.25s}.side-nav-panel .side-nav-level .side-nav-menu{height:100%;margin:0%;padding:0%;transition:all 0.4s linear 0s;width:100%}.side-nav-panel .side-nav-level .collapse:not(.show){display:none}.side-nav-panel .side-nav-level .collapsing{height:0;opacity:0;position:relative;transition:height 0.25s ease-in 0s}.side-nav-panel .side-nav-level .level-heading{color:var(--modus-side-navigation-item-color, #252a2e);display:flex;flex-direction:column;font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\" !important;padding-left:1.25rem}.side-nav-panel .side-nav-level .level-heading svg.icon-chevron-left-thick{padding-right:1rem}.side-nav-panel .side-nav-level .level-heading svg.icon-chevron-left-thick path{fill:var(--modus-side-navigation-item-chevron-color, #252a2e)}.side-nav-panel .side-nav-level .level-heading:focus{border:none;outline:none}.side-nav-panel .side-nav-level .level-heading p{align-items:center;display:flex;margin-block-end:0}.side-nav-panel .side-nav-level .level-heading p a{padding-left:1rem}.side-nav-panel .side-nav-level .level-heading h4{margin-block-end:1em}.side-nav-panel .side-nav-level .level-heading a{color:var(--modus-side-navigation-link-color, #217cbb);cursor:pointer;font-size:0.875rem !important}.side-nav-panel .side-nav-level .level-heading a:hover{text-decoration:underline}.side-nav-panel .side-nav-level.left .side-nav-menu{transform:translateX(-100%)}.side-nav-panel .side-nav-level.center .side-nav-menu{transform:translate(0%)}.side-nav-panel .side-nav-level.right .side-nav-menu{transform:translate(100%)}";
const ModusSideNavigationStyle0 = modusSideNavigationCss;

const ModusSideNavigation$1 = /*@__PURE__*/ proxyCustomElement(class ModusSideNavigation extends HTMLElement {
    constructor() {
        super();
        this.__registerHost();
        this.__attachShadow();
        this.sideNavExpand = createEvent(this, "sideNavExpand", 7);
        this._callbackQueue = []; // eslint-disable-line @typescript-eslint/no-explicit-any
        this._children = {};
        this._minWidth = '4rem';
        this._retainFocus = false;
        // Trick to restart an element's animation
        // see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
        // taken from: https://getbootstrap.com/docs/5.2/dist/js/bootstrap.js
        this.reflow = (element) => {
        };
        this.collapseOnClickOutside = true;
        this.data = undefined;
        this.maxWidth = '256px';
        this.mode = 'overlay';
        this.expanded = false;
        this.targetContent = undefined;
        this._navigationLevels = [];
    }
    componentDidRender() {
        var _a;
        // Execute the callbacks on Render
        // Be careful with updating states in these callbacks to avoid infinite looping
        if ((_a = this._callbackQueue) === null || _a === void 0 ? void 0 : _a.length) {
            this._callbackQueue.forEach((callbackFn) => callbackFn && callbackFn());
        }
        this._callbackQueue = [];
    }
    componentWillLoad() {
        this.handleExpandedChange(this.expanded);
        // If data prop is set, get the level1 info
        this.initializeLevelInfo(this.data);
    }
    documentClickHandler(event) {
        if (!this.collapseOnClickOutside || this.element.contains(event.target) || event.defaultPrevented)
            return;
        // Collapse when clicked outside
        this.expanded = false;
    }
    getNextLevel(id) {
        var _a;
        if ((_a = this._navigationLevels) === null || _a === void 0 ? void 0 : _a.length) {
            const existingLevelItems = this._navigationLevels[this._navigationLevels.length - 1].children;
            return existingLevelItems === null || existingLevelItems === void 0 ? void 0 : existingLevelItems.find((i) => i.id === id);
        }
        return null;
    }
    gotoNextLevel(id) {
        var _a;
        if ((_a = this._navigationLevels) === null || _a === void 0 ? void 0 : _a.length) {
            const level = this.getNextLevel(id);
            if (level === null || level === void 0 ? void 0 : level.children) {
                const newLevels = [...(this._navigationLevels || [])];
                newLevels.push(Object.assign(Object.assign({}, level), { levelPosition: 'right' }));
                this._navigationLevels = [...newLevels];
                this.expanded = true;
                // Animation for sliding levels
                this._callbackQueue.push(() => {
                    const levels = [...this._navigationLevels];
                    levels.forEach((level, index) => {
                        if (index === levels.length - 2) {
                            level.levelPosition = 'left';
                        }
                        else if (index === levels.length - 1) {
                            level.levelPosition = 'center';
                        }
                    });
                    this._navigationLevels = [...levels];
                    this._retainFocus = true;
                });
                return true;
            }
        }
        return false;
    }
    gotoPreviousLevel() {
        var _a, _b;
        if (!((_a = this._navigationLevels) === null || _a === void 0 ? void 0 : _a.length) || ((_b = this._navigationLevels) === null || _b === void 0 ? void 0 : _b.length) === 1)
            return false;
        const levels = [...this._navigationLevels];
        // Animation for sliding levels
        levels.forEach((level, index) => {
            if (levels.length > 1) {
                if (index === levels.length - 2) {
                    level.levelPosition = 'center';
                }
                else if (index === levels.length - 1) {
                    level.levelPosition = 'right';
                }
            }
            else {
                level.levelPosition = 'center';
            }
        });
        this._navigationLevels = [...levels];
        this._callbackQueue.push(() => {
            this._timeout = setTimeout(() => {
                levels.pop();
                this._navigationLevels = [...levels];
                this._retainFocus = true;
                clearTimeout(this._timeout);
            }, 250);
        });
        return true;
    }
    handleItemAdded(event) {
        var _a;
        if ((_a = event.detail) === null || _a === void 0 ? void 0 : _a.id) {
            this._children[event.detail.id] = event.detail;
            this._children[event.detail.id].expanded = this.expanded;
        }
        this.itemChanged(event);
    }
    handleItemRemoved(event) {
        var _a;
        if ((_a = event.detail) === null || _a === void 0 ? void 0 : _a.id) {
            delete this._children[event.detail.id];
        }
        this.itemChanged(event);
    }
    handleItemFocus(event) {
        this.setFocusItem(event.detail.id);
    }
    handleItemClick(event) {
        if (!this.gotoNextLevel(event.detail.id)) {
            if (this._itemSelected) {
                this._children[this._itemSelected].selected = false;
                this._itemSelected = null;
            }
            this._itemSelected = event.detail.selected ? event.detail.id : null;
        }
    }
    handleDataChange(val) {
        this.initializeLevelInfo(val);
    }
    handleExpandedChange(expand) {
        var _a;
        const toggleNavItems = () => {
            Object.values(this._children).forEach((c) => (c.expanded = expand));
        };
        const adjustTargetContent = () => {
            this.setTargetContentMargin(expand, this.mode, this.targetContent);
        };
        const emitExpandedEvent = () => {
            var _a;
            (_a = this.sideNavExpand) === null || _a === void 0 ? void 0 : _a.emit(this.expanded);
        };
        const levelHeading = (_a = this._levelsContainerRef) === null || _a === void 0 ? void 0 : _a.querySelector('.side-nav-level.center .level-heading');
        // Trigger Animation if the current level has a heading
        if (levelHeading) {
            if (expand) {
                levelHeading.classList.remove('collapse');
                levelHeading.classList.add('collapsing');
                levelHeading.style.height = '0';
                this._timeout = setTimeout(() => {
                    levelHeading.classList.remove('collapsing');
                    levelHeading.classList.add('show');
                    levelHeading.style.height = '';
                    clearTimeout(this._timeout);
                    toggleNavItems();
                    emitExpandedEvent();
                }, 150);
                levelHeading.style.height = `${levelHeading.scrollHeight}px`;
                adjustTargetContent();
            }
            else {
                toggleNavItems();
                levelHeading.style.height = `${levelHeading.getBoundingClientRect().height}px`;
                this.reflow(levelHeading);
                levelHeading.classList.add('collapsing');
                // Timeout to reset collapsing class
                this._timeout = setTimeout(() => {
                    levelHeading.classList.remove('show');
                    levelHeading.classList.remove('collapsing');
                    levelHeading.classList.add('collapse');
                    clearTimeout(this._timeout);
                    emitExpandedEvent();
                }, 300);
                levelHeading.style.height = '0px';
                adjustTargetContent();
            }
        }
        else {
            toggleNavItems();
            adjustTargetContent();
            emitExpandedEvent();
        }
    }
    handleModeChange(mode) {
        this.setTargetContentMargin(this.expanded, mode, this.targetContent);
    }
    handleTargetChange(target) {
        this.setTargetContentMargin(this.expanded, this.mode, target);
    }
    handleBackClick(e) {
        var _a;
        const code = (_a = e['code']) === null || _a === void 0 ? void 0 : _a.toUpperCase();
        if (code) {
            if (code === 'ENTER' || code === 'SPACE') {
                this.gotoPreviousLevel();
            }
        }
        else
            this.gotoPreviousLevel();
        e.stopPropagation();
    }
    handleKeyDown(event) {
        var _a, _b;
        if (event.defaultPrevented) {
            return; // Do nothing if event already handled
        }
        const key = event.code.toUpperCase();
        let preventDefault = false;
        // If the tree is empty there will be no child
        if (event.altKey || !this._firstChild) {
            return;
        }
        switch (key) {
            case 'SPACE':
            case 'ENTER':
                event.stopPropagation();
                break;
            case 'ARROWDOWN':
                // eslint-disable-next-line no-case-declarations
                const nextItem = (_a = this._children[this._itemInFocus]) === null || _a === void 0 ? void 0 : _a.nextElementSibling;
                nextItem === null || nextItem === void 0 ? void 0 : nextItem.focusItem();
                preventDefault = true;
                break;
            case 'ARROWUP':
                // eslint-disable-next-line no-case-declarations
                const prevItem = (_b = this._children[this._itemInFocus]) === null || _b === void 0 ? void 0 : _b.previousElementSibling;
                prevItem === null || prevItem === void 0 ? void 0 : prevItem.focusItem();
                preventDefault = true;
                break;
            case 'ARROWRIGHT':
                if (this.expanded)
                    this.gotoNextLevel(this._itemInFocus);
                break;
            case 'ARROWLEFT':
                if (this.expanded)
                    this.gotoPreviousLevel();
                break;
        }
        if (preventDefault) {
            event.preventDefault();
            event.stopPropagation();
        }
    }
    handleLevelsContainerRef(el) {
        this._levelsContainerRef = el;
        // Workaround to retain focus on the component in specific cases
        // Like going back to a level, the component loses focus
        if (this._retainFocus)
            el.focus();
        this._retainFocus = false;
    }
    handleLevelHeadingRef(el) {
        // Retain focus on the current level headings
        el === null || el === void 0 ? void 0 : el.focus();
    }
    initializeLevelInfo(data) {
        if (data === null || data === void 0 ? void 0 : data.length) {
            this._navigationLevels = [
                {
                    id: null,
                    label: null,
                    children: data,
                    levelPosition: 'center',
                },
            ];
        }
        else
            this._navigationLevels = null;
    }
    itemChanged(event) {
        const keys = Object.keys(this._children);
        this._firstChild = keys[0];
        event.preventDefault();
        event.stopPropagation();
    }
    setTargetContentMargin(isExpanded, mode, target) {
        const content = document.querySelector(target);
        if (content) {
            content.style.marginLeft = isExpanded && mode === 'push' ? this.maxWidth : this._minWidth;
        }
    }
    setFocusItem(itemId) {
        this._itemInFocus = itemId;
    }
    render() {
        return (h("nav", { key: 'bdeaa37cdf3b1f0b39999fd1a79d4b9f46e095e3', class: `side-nav-panel${this.expanded ? ' expanded' : ''}`, style: { width: this.expanded ? this.maxWidth : null }, onKeyDown: (e) => this.handleKeyDown(e), "aria-label": "side navigation" }, this.data ? (h("div", { tabindex: -1, ref: (el) => this.handleLevelsContainerRef(el) }, this._navigationLevels.map((level, index) => (h("div", { class: `side-nav-level ${level.levelPosition}`, "aria-hidden": level.levelPosition !== 'center' ? 'true' : null }, index !== 0 && (h("div", Object.assign({ class: "level-heading" }, (level.levelPosition === 'center'
            ? {
                tabindex: 0,
                ref: (el) => this.handleLevelHeadingRef(el),
            }
            : {})), h("p", null, h(IconChevronLeft, { size: "24" }), h("a", { tabIndex: 0, onClick: (e) => this.handleBackClick(e), onKeyDown: (e) => this.handleBackClick(e) }, "Back")), h("h4", null, level.label))), h("div", null, h("ul", { class: "side-nav-menu", role: "tree" }, h(ModusSideNavigationTree, { data: level.children, itemSelected: this._itemSelected, tabIndex: level.levelPosition === 'center' ? undefined : -1 })))))))) : (h("div", { class: "side-nav-level center" }, h("ul", { class: "side-nav-menu", role: "tree" }, h("slot", null))))));
    }
    get element() { return this; }
    static get watchers() { return {
        "data": ["handleDataChange"],
        "expanded": ["handleExpandedChange"],
        "mode": ["handleModeChange"],
        "targetContent": ["handleTargetChange"]
    }; }
    static get style() { return ModusSideNavigationStyle0; }
}, [1, "modus-side-navigation", {
        "collapseOnClickOutside": [4, "collapse-on-click-outside"],
        "data": [16],
        "maxWidth": [1, "max-width"],
        "mode": [1],
        "expanded": [1540],
        "targetContent": [1, "target-content"],
        "_navigationLevels": [32]
    }, [[4, "click", "documentClickHandler"], [0, "_sideNavItemAdded", "handleItemAdded"], [0, "_sideNavItemRemoved", "handleItemRemoved"], [0, "sideNavItemFocus", "handleItemFocus"], [0, "sideNavItemClicked", "handleItemClick"]], {
        "data": ["handleDataChange"],
        "expanded": ["handleExpandedChange"],
        "mode": ["handleModeChange"],
        "targetContent": ["handleTargetChange"]
    }]);
function defineCustomElement$1() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = ["modus-side-navigation", "modus-side-navigation-item", "modus-tooltip"];
    components.forEach(tagName => { switch (tagName) {
        case "modus-side-navigation":
            if (!customElements.get(tagName)) {
                customElements.define(tagName, ModusSideNavigation$1);
            }
            break;
        case "modus-side-navigation-item":
            if (!customElements.get(tagName)) {
                defineCustomElement$3();
            }
            break;
        case "modus-tooltip":
            if (!customElements.get(tagName)) {
                defineCustomElement$2();
            }
            break;
    } });
}

const ModusSideNavigation = ModusSideNavigation$1;
const defineCustomElement = defineCustomElement$1;

export { ModusSideNavigation, defineCustomElement };
