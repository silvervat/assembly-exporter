import { h, proxyCustomElement, HTMLElement, Host } from '@stencil/core/internal/client';
import { g as KEYBOARD_ENTER, k as KEYBOARD_SPACE, h as KEYBOARD_ESCAPE, D as COLUMN_DEF_CELL_EDITOR_ARGS_KEY, c as COLUMN_DEF_DATATYPE_KEY, v as CELL_EDIT_TYPE_TEXT, F as ALLOWED_CELL_EDIT_TYPES, G as COLUMN_DEF_DATATYPE_BADGE, d as COLUMN_DEF_DATATYPE_INTEGER, I as COLUMN_DEF_DATATYPE_LINK, J as COLUMN_DEF_CELL_EDITOR_TYPE_KEY } from './modus-table.constants.js';
import { N as NavigateTableCells } from './table-cell-navigation.utility.js';
import { d as defineCustomElement$9 } from './modus-autocomplete2.js';
import { d as defineCustomElement$8 } from './modus-badge2.js';
import { d as defineCustomElement$7 } from './modus-chip2.js';
import { d as defineCustomElement$6 } from './modus-date-input2.js';
import { d as defineCustomElement$5 } from './modus-date-picker2.js';
import { d as defineCustomElement$4 } from './modus-number-input2.js';
import { d as defineCustomElement$3 } from './modus-select2.js';
import { d as defineCustomElement$2 } from './modus-table-cell-editor2.js';
import { d as defineCustomElement$1 } from './modus-text-input2.js';

// Code taken from - https://github.com/TanStack/table/blob/main/packages/react-table/src/index.tsx
/**
 * Cell formatter enables formatting of a cell value.
 */
function CellFormatter(Comp, props) {
    return !Comp ? null : isFunction(Comp) ? h(Comp, Object.assign({}, props)) : Comp;
}
/**
 * Checks if the input for cell formatter is a function object.
 */
function isFunction(component) {
    return isClassComponent(component) || typeof component === 'function';
}
function isClassComponent(component) {
    return (typeof component === 'function' &&
        (() => {
            const proto = Object.getPrototypeOf(component);
            return proto.prototype && proto.prototype.isFunctionalComponent;
        })());
}

const ModusTableCellLinkElement = ({ link, onLinkClick }) => {
    function handleLinkKeyDown(e) {
        const key = e.key.toLowerCase();
        if (key === KEYBOARD_ENTER || key === KEYBOARD_SPACE) {
            onLinkClick(link);
            e.stopImmediatePropagation();
        }
    }
    return (h("div", { class: "cell-link", tabIndex: 0, onClick: () => onLinkClick(link), onKeyDown: handleLinkKeyDown }, link.display));
};

const ModusTableCellBadgeElement = ({ badge, onBadgeClick }) => {
    function handleBadgeKeyDown(e) {
        const key = e.key.toLowerCase();
        if (key === KEYBOARD_ENTER || key === KEYBOARD_SPACE) {
            onBadgeClick(badge);
            e.stopImmediatePropagation();
        }
    }
    return (h("div", { class: "cell-badge", onClick: () => onBadgeClick(badge), onKeyDown: () => handleBadgeKeyDown },
        h("modus-badge", { tabIndex: 0, color: badge.color, size: badge.size, type: badge.type, ariaLabel: badge === null || badge === void 0 ? void 0 : badge.ariaLabel }, badge.text)));
};

// eslint-disable-next-line
const IconChevronDownThick = (props) => {
    var _a, _b, _c;
    return (h("svg", { class: `icon-chevron-down-thick ${props.pressed ? 'pressed' : ''}`, xmlns: "http://www.w3.org/2000/svg", fill: (_a = props.color) !== null && _a !== void 0 ? _a : 'currentColor', height: (_b = props.size) !== null && _b !== void 0 ? _b : 16, width: (_c = props.size) !== null && _c !== void 0 ? _c : 16, onClick: props.onClick, viewBox: "0 0 24 24" },
        h("path", { d: "M15.88 9.29 12 13.17 8.12 9.29a.996.996 0 1 0-1.41 1.41l4.59 4.59c.39.39 1.02.39 1.41 0l4.59-4.59a.996.996 0 0 0 0-1.41c-.39-.38-1.03-.39-1.42 0z" })));
};

// eslint-disable-next-line
const IconChevronUpThick = (props) => {
    var _a, _b, _c;
    return (h("svg", { class: `icon-chevron-up-thick ${props.pressed ? 'pressed' : ''}`, xmlns: "http://www.w3.org/2000/svg", fill: (_a = props.color) !== null && _a !== void 0 ? _a : 'currentColor', height: (_b = props.size) !== null && _b !== void 0 ? _b : 16, width: (_c = props.size) !== null && _c !== void 0 ? _c : 16, onClick: props.onClick, viewBox: "0 0 24 24" },
        h("path", { d: "M11.29 8.71 6.7 13.3a.996.996 0 1 0 1.41 1.41L12 10.83l3.88 3.88a.996.996 0 1 0 1.41-1.41L12.7 8.71a.996.996 0 0 0-1.41 0z" })));
};

const ModusTableCellExpandIcons = ({ row }) => {
    let expandEl;
    return (h("span", { class: "expand-icon-container", ref: (ref) => (expandEl = ref), style: { paddingLeft: `${row.depth * 2}rem` }, onClick: (e) => {
            row.getToggleExpandedHandler()();
            e.stopImmediatePropagation();
        } }, row.getCanExpand() && (h("span", { class: "expand-icon", tabIndex: 0, onKeyDown: (event) => {
            if (event.key.toLowerCase() === KEYBOARD_ENTER || event.key.toLowerCase() === KEYBOARD_SPACE) {
                expandEl.click();
                event.stopImmediatePropagation();
            }
        } }, row.getIsExpanded() ? h(IconChevronUpThick, { size: '24' }) : h(IconChevronDownThick, { size: '24' })))));
};

const ModusTableCellMain = /*@__PURE__*/ proxyCustomElement(class ModusTableCellMain extends HTMLElement {
    constructor() {
        super();
        this.__registerHost();
        this.onCellClick = (e) => this.handleCellClick(e);
        this.onCellKeyDown = (e) => this.handleCellKeydown(e);
        this.onCellBlur = (e) => this.handleCellBlur(e);
        this.cellEditableKey = 'cellEditable';
        this.accessorKey = 'accessorKey';
        this.handleCellClick = (event) => {
            if (event.defaultPrevented)
                return;
            if (this.cell.column.columnDef[this.cellEditableKey]) {
                this.editMode = true;
            }
        };
        this.handleCellBlur = (event) => {
            if (!this.el.contains(event.relatedTarget)) {
                this.editMode = false;
            }
        };
        this.handleCellKeydown = (event) => {
            var _a;
            if (event.defaultPrevented)
                return;
            const key = (_a = event.key) === null || _a === void 0 ? void 0 : _a.toLowerCase();
            const isCellEditable = this.cell.column.columnDef[this.cellEditableKey];
            if (isCellEditable && !this.editMode && key === KEYBOARD_ENTER) {
                this.editMode = true;
                event.stopPropagation();
            }
            else {
                NavigateTableCells({
                    eventKey: event.key,
                    cellElement: this.cellEl,
                });
            }
        };
        this.handleCellEditorKeyDown = (event, newValue, oldValue) => {
            var _a;
            const key = (_a = event.key) === null || _a === void 0 ? void 0 : _a.toLowerCase();
            if (key === KEYBOARD_ENTER) {
                this.handleCellEditorValueChange(newValue, oldValue);
                NavigateTableCells({
                    eventKey: KEYBOARD_ENTER,
                    cellElement: this.cellEl,
                });
            }
            else if (key === KEYBOARD_ESCAPE) {
                this.editMode = false;
                this.cellEl.focus();
            }
            else
                return;
            event.stopPropagation();
        };
        this.cell = undefined;
        this.context = undefined;
        this.hasRowsExpandable = undefined;
        this.valueChange = undefined;
        this.editMode = undefined;
    }
    onEditModeChange(newValue) {
        if (newValue)
            this.cellEl.classList.add('edit-mode');
        else
            this.cellEl.classList.remove('edit-mode');
    }
    connectedCallback() {
        this.cellEl = this.el.parentElement;
        this.cellEl.addEventListener('click', this.onCellClick);
        this.cellEl.addEventListener('keydown', this.onCellKeyDown);
        this.cellEl.addEventListener('blur', this.onCellBlur);
    }
    disconnectedCallback() {
        if (this.cellEl) {
            this.cellEl.removeEventListener('click', this.onCellClick);
            this.cellEl.removeEventListener('keydown', this.onCellKeyDown);
            this.cellEl.removeEventListener('blur', this.onCellBlur);
        }
    }
    getEditorType() {
        const editorType = this.cell.column.columnDef[COLUMN_DEF_CELL_EDITOR_TYPE_KEY];
        const dataType = this.cell.column.columnDef[COLUMN_DEF_DATATYPE_KEY];
        let editorTypeToReturn = CELL_EDIT_TYPE_TEXT;
        if (!editorType) {
            if (ALLOWED_CELL_EDIT_TYPES.includes(dataType))
                editorTypeToReturn = dataType;
        }
        else {
            editorTypeToReturn = editorType;
        }
        return editorTypeToReturn;
    }
    getEditorArgs() {
        return this.cell.column.columnDef[COLUMN_DEF_CELL_EDITOR_ARGS_KEY];
    }
    /**
     * Returns whether a cell is editable based on row index and column ID.
     * @param rowIndex The index of the row.
     * @param columnId The ID of the column.
     * @returns Boolean indicating if the cell is editable.
     */
    async handleCellEdit(rowIndex, columnId) {
        const tableInstance = this.cell.getContext().table;
        const row = tableInstance.getRowModel().rows[rowIndex];
        if (!row)
            return;
        const cell = row.getAllCells().find((cell) => cell.column.id === columnId);
        if (!cell)
            return;
        // Focus on the cell element
        const cellElement = this.el.querySelector(`[data-cell-id="${rowIndex}-${columnId}"]`);
        if (cellElement) {
            cellElement.focus();
        }
        this.editMode = true;
    }
    handleCellEditorValueChange(newValue, oldValue) {
        if (this.editMode && newValue !== oldValue && this.valueChange) {
            this.valueChange({
                row: this.cell.row,
                accessorKey: this.cell.column.columnDef[this.accessorKey],
                newValue,
                oldValue,
            });
        }
        this.editMode = false;
    }
    renderCellValue() {
        var _a;
        const { row, getValue } = this.cell;
        const cellValue = getValue();
        if (cellValue === null || cellValue === undefined)
            return null;
        const { cellLinkClick, wrapText } = this.context;
        const cellDataType = (_a = cellValue['_type']) !== null && _a !== void 0 ? _a : this.cell.column.columnDef[COLUMN_DEF_DATATYPE_KEY];
        const wrap = cellDataType === COLUMN_DEF_DATATYPE_BADGE ? false : wrapText;
        const classes = {
            'cell-content': true,
            'truncate-text': !wrap,
            'wrap-text': wrap,
            'text-align-right': cellDataType === COLUMN_DEF_DATATYPE_INTEGER,
        };
        const renderCell = () => {
            if (cellDataType === COLUMN_DEF_DATATYPE_LINK) {
                return (h(ModusTableCellLinkElement, { link: cellValue, onLinkClick: (link) => {
                        this.cellEl.focus();
                        cellLinkClick.emit(link);
                    } }));
            }
            else if (cellDataType === COLUMN_DEF_DATATYPE_BADGE) {
                return (h(ModusTableCellBadgeElement, { badge: cellValue, onBadgeClick: () => {
                        this.cellEl.focus();
                    } }));
            }
            else {
                return CellFormatter(this.cell.column.columnDef.cell, this.cell.getContext());
            }
        };
        return (h("div", { class: classes }, this.hasRowsExpandable && h(ModusTableCellExpandIcons, { row: row }), h("span", { class: wrap ? 'wrap-text' : 'truncate-text' }, renderCell())));
    }
    render() {
        var _a;
        const valueString = (_a = this.cell.getValue()) === null || _a === void 0 ? void 0 : _a.toString();
        return (h(Host, { key: 'df7d9a18b6bc172a9f8dd51521b5ddcca1fb9e9c' }, this.editMode ? (h("modus-table-cell-editor", { "data-type": this.cell.column.columnDef[COLUMN_DEF_DATATYPE_KEY], value: this.cell.getValue(), type: this.getEditorType(), args: this.getEditorArgs(), valueChange: (newVal) => this.handleCellEditorValueChange(newVal, valueString), keyDown: (event, newVal) => this.handleCellEditorKeyDown(event, newVal, valueString) })) : (this.renderCellValue())));
    }
    get el() { return this; }
    static get watchers() { return {
        "editMode": ["onEditModeChange"]
    }; }
}, [0, "modus-table-cell-main", {
        "cell": [16],
        "context": [16],
        "hasRowsExpandable": [4, "has-rows-expandable"],
        "valueChange": [16],
        "editMode": [32],
        "handleCellEdit": [64]
    }, undefined, {
        "editMode": ["onEditModeChange"]
    }]);
function defineCustomElement() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = ["modus-table-cell-main", "modus-autocomplete", "modus-badge", "modus-chip", "modus-date-input", "modus-date-picker", "modus-number-input", "modus-select", "modus-table-cell-editor", "modus-text-input"];
    components.forEach(tagName => { switch (tagName) {
        case "modus-table-cell-main":
            if (!customElements.get(tagName)) {
                customElements.define(tagName, ModusTableCellMain);
            }
            break;
        case "modus-autocomplete":
            if (!customElements.get(tagName)) {
                defineCustomElement$9();
            }
            break;
        case "modus-badge":
            if (!customElements.get(tagName)) {
                defineCustomElement$8();
            }
            break;
        case "modus-chip":
            if (!customElements.get(tagName)) {
                defineCustomElement$7();
            }
            break;
        case "modus-date-input":
            if (!customElements.get(tagName)) {
                defineCustomElement$6();
            }
            break;
        case "modus-date-picker":
            if (!customElements.get(tagName)) {
                defineCustomElement$5();
            }
            break;
        case "modus-number-input":
            if (!customElements.get(tagName)) {
                defineCustomElement$4();
            }
            break;
        case "modus-select":
            if (!customElements.get(tagName)) {
                defineCustomElement$3();
            }
            break;
        case "modus-table-cell-editor":
            if (!customElements.get(tagName)) {
                defineCustomElement$2();
            }
            break;
        case "modus-text-input":
            if (!customElements.get(tagName)) {
                defineCustomElement$1();
            }
            break;
    } });
}

export { ModusTableCellMain as M, defineCustomElement as d };
