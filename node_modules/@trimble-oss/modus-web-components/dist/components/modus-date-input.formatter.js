const monthsFull = [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December',
];
const monthsShort = monthsFull.map((m) => m.substring(0, 3));
function pad(val) {
    if (val < 10)
        return `0${val}`;
    return val.toString();
}
//date.toLocaleString('en-US', { month: 'short' })
const Tokens = {
    mmmm: { regex: `(${monthsFull.join('|')})`, type: 'month' },
    mmm: { regex: `(${monthsShort.join('|')})`, type: 'month' },
    mm: { regex: '(1[0-2]|0?[1-9])', type: 'month' },
    m: { regex: '(1[0-2]|0?[1-9])', type: 'month' },
    dd: { regex: '(3[01]|0?[1-9]|[12][0-9])', type: 'date' },
    d: { regex: '(3[01]|0?[1-9]|[12][0-9])', type: 'date' },
    yy: { regex: '(\\d{2})', type: 'year' },
    yyyy: { regex: '(\\d{4})', type: 'year' },
};
const TokenFormatting = {
    m: function (val) {
        return `${val}`;
    },
    mm: function (val) {
        return pad(val);
    },
    mmm: function (val) {
        return monthsShort[val - 1];
    },
    mmmm: function (val) {
        return monthsFull[val - 1];
    },
    d: function (val) {
        return `${val}`;
    },
    dd: function (val) {
        return pad(val);
    },
    yy: function (val) {
        return pad(val).substring(2);
    },
    yyyy: function (val, fillerYear) {
        if (val < 100) {
            const fill = fillerYear || new Date().getFullYear();
            return `${String(fill).substring(0, 2)}${pad(val)}`;
        }
        else
            return `${val}`;
    },
};
const defaultParser = function (val) {
    return parseFloat(val);
};
const TokenParser = {
    m: defaultParser,
    mm: defaultParser,
    mmm: function (val) {
        return monthsShort.findIndex((m) => m.toUpperCase() === (val === null || val === void 0 ? void 0 : val.toUpperCase())) + 1;
    },
    mmmm: function (val) {
        return monthsFull.findIndex((m) => m.toUpperCase() === (val === null || val === void 0 ? void 0 : val.toUpperCase())) + 1;
    },
    d: defaultParser,
    dd: defaultParser,
    yy: defaultParser,
    yyyy: defaultParser,
};

const ISO_DATE_FORMAT = /^(\d{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])/;
class DateInputFormatter {
    constructor(fillerDateString, format) {
        const [regex, tokens, separators] = this.buildRegexAndTokens(format);
        if (regex && tokens) {
            this._dateRegExp = regex;
            this._dateTokens = tokens;
            this._displayFormat = format;
            this._tokenSeparators = separators;
        }
        this._fillerDate = this.getFillerDate(fillerDateString);
    }
    /**
     * Note: Auto formatting is not used yet due to the challenges in handling formats like 'm' and 'd' where the user can input single or double-digit
     */
    autoFormatInput(val, autoFormat) {
        if (!val || !autoFormat)
            return val;
        const separator = this._tokenSeparators.get(val.length);
        if (separator) {
            return val + separator;
        }
        return val;
    }
    /**
     * Build a regular expression from the date format
     * Returns an array of regular expression, date tokens, token separators
     */
    buildRegexAndTokens(format) {
        const dtTokens = new Map();
        const regexParts = [];
        const separators = new Map();
        for (let i = 0; i < format.length; i++) {
            let token = format[i];
            const tokens = [token];
            while (format[i + 1] === token) {
                tokens.push(token);
                ++i;
            }
            const validToken = tokens.join('');
            const tokenInfo = Tokens[validToken];
            if (tokenInfo && tokenInfo.regex) {
                dtTokens.set(tokenInfo.type, {
                    index: dtTokens.size,
                    tokenString: validToken,
                });
                token = tokenInfo.regex;
            }
            else {
                separators.set(i, token);
            }
            regexParts.push(token);
        }
        return [`^${regexParts.join('')}$`, dtTokens, separators];
    }
    /** Format value in ISO 8601 date format to the display format */
    formatDisplayString(val) {
        const regex = new RegExp(ISO_DATE_FORMAT);
        const parse = regex.exec(val);
        if (parse) {
            parse.shift();
            const parts = {
                year: parseFloat(parse[0]),
                month: parseFloat(parse[1]),
                date: parseFloat(parse[2]),
            };
            let output = this._displayFormat;
            this._dateTokens.forEach(({ tokenString }, key) => {
                const formatting = TokenFormatting[tokenString];
                output = output.replace(tokenString, formatting(parts[key], key === 'year' ? this._fillerDate.getFullYear() : null));
            });
            return output;
        }
        return null;
    }
    /** Parse display string to ISO 8601 date format YYYY-MM-DD */
    parseDisplayString(val) {
        if (this._dateRegExp && val) {
            const regexObj = new RegExp(this._dateRegExp, 'i');
            const output = regexObj.exec(val);
            if (output) {
                // parsed[0] always contains the whole string
                output.shift();
                const monthToken = this._dateTokens.get('month');
                const dateToken = this._dateTokens.get('date');
                const yearToken = this._dateTokens.get('year');
                const month = monthToken
                    ? TokenParser[monthToken.tokenString](output[monthToken.index])
                    : this._fillerDate.getMonth() + 1;
                const date = dateToken ? TokenParser[dateToken.tokenString](output[dateToken.index]) : this._fillerDate.getDate();
                const year = yearToken
                    ? TokenParser[yearToken.tokenString](output[yearToken.index])
                    : this._fillerDate.getFullYear();
                const isoDateString = `${TokenFormatting.yyyy(year, this._fillerDate.getFullYear())}-${TokenFormatting.mm(month)}-${TokenFormatting.dd(date)}`;
                return Date.parse(isoDateString) ? isoDateString : null;
            }
        }
        return null;
    }
    /**
     * Filler date is used as fillers for parts not in the display format when constructing a full date string,
     * ex: 'yyyy-mm' format doesn't have a date part, hence the date is picked from filler  */
    getFillerDate(val) {
        return this.parseIsoToDate(val) || new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0);
    }
    parseIsoToDate(val) {
        if (!val) {
            return null;
        }
        const regex = new RegExp(ISO_DATE_FORMAT);
        const parse = regex.exec(val);
        if (parse) {
            parse.shift();
            return new Date(parseFloat(parse[0]), parseFloat(parse[1]) - 1, parseFloat(parse[2]));
        }
        return null;
    }
}

export { DateInputFormatter as D, ISO_DATE_FORMAT as I };
