import { proxyCustomElement, HTMLElement, h } from '@stencil/core/internal/client';
import { M as ModusIconMap } from './ModusIconMap.js';
import { I as ISO_DATE_FORMAT } from './modus-date-input.formatter.js';

const MONTH_NAMES = [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December',
];
class ModusDatePickerCalendar {
    constructor(calendar) {
        if (calendar) {
            this.gotoDate(calendar.currentDate.getFullYear(), calendar.currentDate.getMonth());
        }
        else {
            const today = new Date();
            this.gotoDate(today.getFullYear(), today.getMonth());
        }
    }
    get year() {
        return this.currentDate.getFullYear().toString();
    }
    get month() {
        return MONTH_NAMES[this.currentDate.getMonth()];
    }
    get selectedYear() {
        return this.currentDate.getFullYear();
    }
    get selectedMonth() {
        return this.currentDate.getMonth();
    }
    get dates() {
        return this.currentMonthDates;
    }
    addMonthOffset(offset) {
        this.gotoDate(this.currentDate.getFullYear(), this.currentDate.getMonth() + offset);
        return this;
    }
    addYearOffset(offset) {
        this.gotoDate(this.currentDate.getFullYear() + offset, this.currentDate.getMonth());
        return this;
    }
    gotoDate(year, month) {
        this.currentDate = new Date(year, month, 1);
        this.calculateDates();
    }
    getDaysOfWeek(locale, firstDayOfWeek = 0) {
        /**
         * Nov 1st, 2020 starts on a Sunday,
         * assumes weeks start on Sunday,
         * but is configurable via `firstDayOfWeek`.
         */
        const intl = new Intl.DateTimeFormat(locale, { weekday: 'short' });
        const startDate = new Date('11/01/2020');
        const daysOfWeek = [];
        /**
         * For each day of the week,
         * get the day name.
         */
        for (let i = firstDayOfWeek; i < firstDayOfWeek + 7; i++) {
            const currentDate = new Date(startDate);
            currentDate.setDate(currentDate.getDate() + i);
            const d = intl.format(currentDate);
            daysOfWeek.push(d.toUpperCase().startsWith('SA') ? d : d.slice(0, 2));
        }
        return daysOfWeek;
    }
    calculateDates() {
        const dates = [];
        const year = this.currentDate.getFullYear();
        const month = this.currentDate.getMonth();
        const date = new Date(year, month, 1);
        while (date.getMonth() === month) {
            dates.push(new Date(date));
            date.setDate(date.getDate() + 1);
        }
        this.currentMonthDates = dates;
    }
}

class ModusDatePickerState {
    constructor(el) {
        var _a;
        this.isOpen = false;
        this.element = el;
        this.element.showCalendarIcon = ((_a = this.element.showCalendarIcon) === null || _a === void 0 ? void 0 : _a.toString().toUpperCase()) !== 'FALSE';
        this.max = this.parseDate(this.element.max);
        this.min = this.parseDate(this.element.min);
        this.refresh();
    }
    getDate() {
        return this.date;
    }
    getMaxDateAllowed() {
        return this.max;
    }
    getMinDateAllowed() {
        return this.min;
    }
    setDate(val) {
        // Converting to ISO8601 'yyyy-mm-dd' format
        if (Number(val)) {
            const year = val.getFullYear();
            const month = (val.getMonth() + 1).toString().padStart(2, '0'); // Zero based number system for months
            const date = val.getDate().toString().padStart(2, '0');
            this.element.value = `${year}-${month}-${date}`;
            this.element.errorText = null;
            this.element.focusInput();
            this.date = val;
        }
    }
    setError(message = null) {
        this.element.errorText = message;
    }
    validateInput() {
        this.element.validate();
    }
    refresh() {
        this.date = this.parseDate(this.element.value);
    }
    parseDate(date) {
        if (!date) {
            return null;
        }
        // Note: Modus Date Input component's value is always in 'yyyy-mm-dd' format
        const dateISORegex = new RegExp(ISO_DATE_FORMAT);
        const parse = dateISORegex.exec(date);
        if (parse) {
            // first element returns the whole date string
            parse.shift();
            return new Date(parseFloat(parse[0]), parseFloat(parse[1]) - 1, // Zero based number system for months
            parseFloat(parse[2]));
        }
        return null;
    }
    toggleCalendar(val = null) {
        this.isOpen = val !== null ? val : !this.isOpen;
    }
    isCalendarOpen() {
        return this.isOpen;
    }
}

const modusDatePickerCss = "@import url(\"https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700\");.modus-date-picker{display:inline-flex;flex-direction:column;font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";position:relative;width:100%}.modus-date-picker .date-inputs{display:grid;grid-gap:0.5rem;grid-template-columns:auto auto}.modus-date-picker button{background:0;border:0;cursor:pointer;display:inline-flex;margin:0;padding:0}.modus-date-picker button.disabled{cursor:default}.modus-date-picker .label-container{display:flex}.modus-date-picker .label-container label{color:var(--modus-input-label-color, #464b52);font-size:0.75rem;margin-bottom:0.25rem}.modus-date-picker .input-container input{font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\"}.modus-date-picker .calendar-container{background-color:var(--modus-date-picker-calendar-body-bg, #fff);border-radius:4px;box-shadow:0 0 4px rgba(0, 0, 0, 0.1607843137);display:flex;flex-direction:column;font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";margin-top:0.15rem;position:absolute;z-index:1}.modus-date-picker .calendar-container .calendar-header{align-items:center;background-color:var(--modus-date-picker-calendar-header-bg, #0063a3);border-top-left-radius:4px;border-top-right-radius:4px;color:var(--modus-date-picker-calendar-header-color, #fff);display:flex;font:normal normal 600 16px/22px \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";height:40px;justify-content:space-around;letter-spacing:0;opacity:1;text-align:center;width:100%}.modus-date-picker .calendar-container .calendar-header svg path{fill:var(--modus-date-picker-calendar-header-color, #fff)}.modus-date-picker .calendar-container .calendar-header .title{align-items:center;display:inline-flex;justify-content:center}.modus-date-picker .calendar-container .calendar-header .calendar-title:focus+.year-icons,.modus-date-picker .calendar-container .calendar-header .calendar-title:hover+.year-icons,.modus-date-picker .calendar-container .calendar-header .calendar-title:active+.year-icons,.modus-date-picker .calendar-container .calendar-header .year-icons:hover,.modus-date-picker .calendar-container .calendar-header .year-icons:focus,.modus-date-picker .calendar-container .calendar-header .year-icons:focus-within{opacity:1 !important}.modus-date-picker .calendar-container .calendar-header .year-icons{display:inline-flex;flex-direction:column;margin-left:0.5rem;opacity:0}.modus-date-picker .calendar-container .calendar-header .year-icons button:active{opacity:0.5}.modus-date-picker .calendar-container .calendar-body{align-items:center;display:flex;flex-direction:column;font-size:0.875rem;justify-content:center;padding:1rem}.modus-date-picker .calendar-container .calendar-body .grid{display:grid;grid-template-columns:repeat(7, 1fr);text-align:center}.modus-date-picker .calendar-container .calendar-body .grid .grid-item{align-items:center;display:flex;height:32px;justify-content:center;width:32px}.modus-date-picker .calendar-container .calendar-body .out-of-range-notification{margin-top:0.6rem;text-align:center}.modus-date-picker .calendar-container .calendar-body .goto-available-dates{color:var(--modus-link-color, #217cbb);cursor:pointer}.modus-date-picker .calendar-container .calendar-body .calendar-days-week{color:var(--modus-date-picker-calendar-day-week-color, #363545);font:normal normal bold 14px/19px \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";letter-spacing:0;opacity:1;text-align:center}.modus-date-picker .calendar-container .calendar-body .calendar-day{color:var(--modus-date-picker-calendar-day-color, #252a2e);font:normal normal normal 14px/19px \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";letter-spacing:0;opacity:1;text-align:center}.modus-date-picker .calendar-container .calendar-body .calendar-day:hover{background:var(--modus-date-picker-calendar-day-hover-bg, #e0e1e9) 0% 0% no-repeat padding-box !important;border-radius:16px}.modus-date-picker .calendar-container .calendar-body .calendar-day.current-day{background:var(--modus-date-picker-calendar-body-bg, #fff) 0% 0% no-repeat padding-box;border:2px solid var(--modus-date-picker-calendar-day-current-border-color, #217cbb);border-radius:16px}.modus-date-picker .calendar-container .calendar-body .calendar-day.selected{background:var(--modus-date-picker-calendar-day-selected-bg, #217cbb) 0% 0% no-repeat padding-box;border-radius:16px;color:var(--modus-date-picker-calendar-day-selected-color, #fff)}.modus-date-picker .calendar-container .calendar-body .calendar-day.selected.start::after,.modus-date-picker .calendar-container .calendar-body .calendar-day.selected.end::after{background-color:var(--modus-date-picker-calendar-day-selected-range-bg, #dcedf9);content:\"\";height:32px;position:absolute;width:32px;z-index:-1}.modus-date-picker .calendar-container .calendar-body .calendar-day.selected.start::after{border-radius:50% 0 0 50% !important}.modus-date-picker .calendar-container .calendar-body .calendar-day.selected.end::after{border-radius:0 50% 50% 0 !important}.modus-date-picker .calendar-container .calendar-body .calendar-day.disabled{opacity:var(--modus-date-picker-calendar-day-disabled-opacity, 0.3);pointer-events:none}.modus-date-picker .calendar-container .calendar-body .calendar-day.range-selected{background:var(--modus-date-picker-calendar-day-selected-range-bg, #dcedf9) 0% 0% no-repeat padding-box}.modus-date-picker .calendar-container .calendar-body .calendar-day.range-selected:hover::before,.modus-date-picker .calendar-container .calendar-body .calendar-day.range-selected.current-day::before{background:var(--modus-date-picker-calendar-day-selected-range-bg, #dcedf9) 0% 0% no-repeat padding-box;content:\"\";height:32px;position:absolute;width:32px;z-index:-1}.modus-date-picker .calendar-container .calendar-body .calendar-month{position:absolute}.modus-date-picker .calendar-container .calendar-body .calendar-month.invalid-date-range .start::after,.modus-date-picker .calendar-container .calendar-body .calendar-month.invalid-date-range .end::after{opacity:0}.modus-date-picker .calendar-container .calendar-body .calendar-month-container{display:flex;height:180px;justify-content:center;position:relative}";
const ModusDatePickerStyle0 = modusDatePickerCss;

const ModusDatePicker = /*@__PURE__*/ proxyCustomElement(class ModusDatePicker extends HTMLElement {
    constructor() {
        super();
        this.__registerHost();
        this.__attachShadow();
        this._dateInputs = {};
        this._locale = 'default';
        this.isInvalidDateRange = (startDate, endDate) => this.compare(endDate, startDate) < 0;
        this.label = undefined;
        this._forceUpdate = {};
        this._showCalendar = false;
        this._showYearArrows = false;
    }
    get _currentInput() {
        return Object.values(this._dateInputs).find((dt) => dt.isCalendarOpen());
    }
    componentWillLoad() {
        this._calendar = new ModusDatePickerCalendar();
    }
    /** Handlers */
    handleCalendarIconClick(event) {
        const { type } = event.detail;
        Object.keys(this._dateInputs).forEach((d) => this._dateInputs[d].toggleCalendar(d === type ? null : false));
        this.toggleCalendar();
        if (this._showCalendar) {
            this.gotoDateBeingPicked(this._dateInputs[type].getDate());
        }
        this.forceUpdate();
    }
    handleClickOutside(event) {
        if (this.element.contains(event.target) || event.defaultPrevented) {
            return;
        }
        // Collapse when clicked outside
        this.toggleCalendar(false);
    }
    handleDateInputValue(event) {
        const { type } = event.detail;
        if (!this._dateInputs[type])
            return;
        this._dateInputs[type].refresh();
        if (this._showCalendar) {
            this.gotoDateBeingPicked(this._dateInputs[type].getDate());
        }
        this.forceUpdate();
    }
    handleDateInputBlur() {
        var _a, _b;
        this.applyDateRangeRules((_a = this._dateInputs['start']) === null || _a === void 0 ? void 0 : _a.getDate(), (_b = this._dateInputs['end']) === null || _b === void 0 ? void 0 : _b.getDate());
    }
    handleSlotChange() {
        const dates = Array.from(this.element.querySelectorAll('modus-date-input'));
        dates === null || dates === void 0 ? void 0 : dates.forEach((d) => {
            this._dateInputs[d.type] = new ModusDatePickerState(d);
        });
    }
    /** Helpers */
    addMonthOffset(offset) {
        this._calendar.addMonthOffset(offset);
        this.forceUpdate();
    }
    addYearOffset(offset) {
        this._calendar.addYearOffset(offset);
        this.forceUpdate();
    }
    applyDateRangeRules(startDate, endDate) {
        if (!startDate || !endDate) {
            return;
        }
        if (this.isInvalidDateRange(startDate, endDate)) {
            this._dateInputs['start'].setError('Invalid date range');
            this._dateInputs['end'].setError();
        }
        else {
            this._dateInputs['start'].validateInput();
            this._dateInputs['end'].validateInput();
        }
    }
    compare(date1, date2) {
        if (!date1 && !date2) {
            return 0;
        }
        else if (!date1 && date2) {
            return -1;
        }
        else if (date1 && !date2) {
            return 1;
        }
        let delta;
        delta = date1.getFullYear() - date2.getFullYear();
        if (delta !== 0) {
            return delta;
        }
        delta = date1.getMonth() - date2.getMonth();
        if (delta !== 0) {
            return delta;
        }
        return date1.getDate() - date2.getDate();
    }
    forceUpdate() {
        this._forceUpdate = Object.assign({}, this._forceUpdate);
    }
    findDatePositionsInARange(date, startDate, endDate) {
        return {
            start: startDate && this.compare(date, startDate) === 0,
            end: endDate && this.compare(date, endDate) === 0,
            'in-range': startDate && endDate && this.compare(date, startDate) > 0 && this.compare(date, endDate) < 0,
        };
    }
    gotoDateBeingPicked(pickedDate) {
        if (!this._showCalendar) {
            return;
        }
        const date = pickedDate || new Date();
        this._calendar.gotoDate(date.getFullYear(), date.getMonth());
    }
    goToNearestBoundaryDate(date) {
        var _a, _b;
        const minDate = (_a = this._currentInput) === null || _a === void 0 ? void 0 : _a.getMinDateAllowed();
        const maxDate = (_b = this._currentInput) === null || _b === void 0 ? void 0 : _b.getMaxDateAllowed();
        const targetDate = this.compare(date, minDate) < 0 ? minDate : maxDate;
        this.gotoDateBeingPicked(targetDate);
        this.forceUpdate();
    }
    pickCalendarDate(date) {
        this._currentInput.setDate(date);
        this.toggleCalendar(false);
    }
    showYearChange(show = true) {
        this._showYearArrows = show;
    }
    isWithinCurrentMinMax(date) {
        var _a, _b;
        const max = (_a = this._currentInput) === null || _a === void 0 ? void 0 : _a.getMaxDateAllowed();
        const min = (_b = this._currentInput) === null || _b === void 0 ? void 0 : _b.getMinDateAllowed();
        if (!date) {
            return false;
        }
        if (min && this.compare(date, min) < 0) {
            return false;
        }
        if (max && this.compare(date, max) > 0) {
            return false;
        }
        return true;
    }
    toggleCalendar(val = null) {
        if (val !== null) {
            this._showCalendar = val;
            if (!this._showCalendar) {
                Object.keys(this._dateInputs || {}).forEach((d) => {
                    this._dateInputs[d].toggleCalendar(false);
                });
            }
        }
        else {
            this._showCalendar = !!Object.values(this._dateInputs).find((dt) => dt.isCalendarOpen());
        }
    }
    renderCalendarBody() {
        var _a, _b, _c, _d;
        const today = new Date();
        const startDate = (_a = this._dateInputs['start']) === null || _a === void 0 ? void 0 : _a.getDate();
        const endDate = (_b = this._dateInputs['end']) === null || _b === void 0 ? void 0 : _b.getDate();
        const singleDate = (_c = this._dateInputs['single']) === null || _c === void 0 ? void 0 : _c.getDate();
        // Get day of the week and prepare blank cells to render the calendar dates properly
        const firstDay = (_d = new Date(this._calendar.selectedYear, this._calendar.selectedMonth)) === null || _d === void 0 ? void 0 : _d.getDay();
        const blankDatesArr = new Array(firstDay).fill(0);
        return (h("div", { class: "calendar-body" }, h("div", { class: "calendar-days-week grid" }, this._calendar.getDaysOfWeek(this._locale).map((d) => {
            return h("div", { class: "grid-item" }, d);
        })), h("div", { class: "calendar-month-container" }, h("div", { class: {
                'calendar-month grid': true,
                'invalid-date-range': this.isInvalidDateRange(startDate, endDate),
            } }, blankDatesArr &&
            blankDatesArr.length > 0 &&
            blankDatesArr.map(() => {
                return (h("button", { class: {
                        'calendar-day grid-item': false,
                        disabled: true,
                    }, disabled: true, tabIndex: -1 }, "\u00A0"));
            }), this._calendar.dates.map((date, index) => {
            if (!date) {
                return null;
            }
            const positions = this.findDatePositionsInARange(date, startDate, endDate);
            const isStartDate = positions['start'];
            const isEndDate = positions['end'];
            const isToday = this.compare(date, today) === 0;
            const isSingleDateSelected = singleDate && this.compare(date, singleDate) === 0;
            const isSelected = isStartDate || isEndDate || isSingleDateSelected;
            const isInRange = !isSelected ? positions['in-range'] : false;
            const isDateDisabled = !this.isWithinCurrentMinMax(date);
            // Only for the last date in the calendar
            const onBlurEvent = index === this._calendar.dates.length - 1
                ? {
                    onBlur: () => {
                        this.toggleCalendar(false);
                    },
                }
                : {};
            return (h("button", Object.assign({ class: {
                    'calendar-day grid-item': true,
                    selected: isSelected,
                    disabled: isDateDisabled,
                    start: isStartDate && !isEndDate,
                    end: isEndDate && !isStartDate,
                    'current-day': isToday,
                    'range-selected': isInRange,
                }, disabled: isDateDisabled, tabIndex: 0, type: "button", "aria-current": isSelected ? 'date' : undefined, onClick: () => this.pickCalendarDate(date) }, onBlurEvent), date.getDate()));
        }))), !this.isWithinCurrentMinMax(this._currentInput.getDate()) && (h("div", { class: "out-of-range-notification" }, h("div", null, "The selected date is not available"), h("span", { class: "goto-available-dates", onClick: () => this.goToNearestBoundaryDate(this._currentInput.getDate()) }, "Go to available dates")))));
    }
    renderCalendarHeader() {
        var _a, _b;
        return (h("div", { class: "calendar-header" }, h("button", { type: "button", "aria-label": "Previous Month", onClick: () => this.addMonthOffset(-1) }, h(ModusIconMap, { icon: "chevron_left_bold" })), h("div", { class: "title" }, h("div", { class: "calendar-title", role: "heading" }, `${(_a = this._calendar) === null || _a === void 0 ? void 0 : _a.month} ${(_b = this._calendar) === null || _b === void 0 ? void 0 : _b.year}`), h("div", { class: "year-icons" }, h("button", { type: "button", tabIndex: 0, "aria-label": "Next Year", onClick: () => this.addYearOffset(1), class: "year-up" }, h(ModusIconMap, { icon: "caret_up", size: "16" })), h("button", { type: "button", tabIndex: 0, "aria-label": "Previous Year", onClick: () => this.addYearOffset(-1), class: "year-down" }, h(ModusIconMap, { size: "16", icon: "caret_down" })))), h("button", { type: "button", tabIndex: 0, "aria-label": "Next Month", onClick: () => this.addMonthOffset(1) }, h(ModusIconMap, { icon: "chevron_right_bold" }))));
    }
    render() {
        return (h("div", { key: '45ef27e63b41e4b08a1c084acfc0b9d9d92070e3', class: "modus-date-picker" }, this.label ? h("div", { class: 'label-container' }, this.label ? h("label", null, this.label) : null) : null, h("div", { key: '8db804f8291c99e8be8434d81491769b8e2ff604', class: "date-inputs", part: "date-inputs" }, h("slot", { key: 'b003c1220288f9aa056c1cabc4e17d0c20851631', onSlotchange: () => this.handleSlotChange() })), h("div", { key: '973e68544060a5c9bc74f15ef79e21815eee3ba7', style: { display: 'inline-flex' } }, this._showCalendar && (h("nav", { class: "calendar-container", "aria-label": "Pick a Date" }, this.renderCalendarHeader(), this.renderCalendarBody())))));
    }
    get element() { return this; }
    static get style() { return ModusDatePickerStyle0; }
}, [1, "modus-date-picker", {
        "label": [1],
        "_forceUpdate": [32],
        "_showCalendar": [32],
        "_showYearArrows": [32]
    }, [[0, "calendarIconClicked", "handleCalendarIconClick"], [4, "click", "handleClickOutside"], [0, "valueChange", "handleDateInputValue"], [0, "dateInputBlur", "handleDateInputBlur"]]]);
function defineCustomElement() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = ["modus-date-picker"];
    components.forEach(tagName => { switch (tagName) {
        case "modus-date-picker":
            if (!customElements.get(tagName)) {
                customElements.define(tagName, ModusDatePicker);
            }
            break;
    } });
}

export { ModusDatePicker as M, defineCustomElement as d };
