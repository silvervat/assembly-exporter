import { proxyCustomElement, HTMLElement, h, Fragment } from '@stencil/core/internal/client';
import { c as createPopper } from './popper.js';

const modusTooltipCss = "@import url(\"https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700\");.tooltip{background:var(--modus-tooltip-bg, #585c65);border-radius:0.25rem;color:var(--modus-tooltip-color, #fff);display:none;font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";font-size:0.75rem;max-width:250px;padding:0.25rem 0.5rem;z-index:1}.tooltip[data-show]:not(.hide){display:inline-block}#arrow,#arrow::before{background:inherit;forced-color-adjust:none;height:8px;position:absolute;width:8px}#arrow{visibility:hidden}#arrow::before{content:\"\";transform:rotate(45deg);visibility:visible}.tooltip[data-popper-placement^=top]>#arrow{bottom:-4px}.tooltip[data-popper-placement^=bottom]>#arrow{top:-4px}.tooltip[data-popper-placement^=left]>#arrow{right:-4px}.tooltip[data-popper-placement^=right]>#arrow{left:-4px}@media (forced-colors: active){.tooltip{border:1px solid transparent}}";
const ModusTooltipStyle0 = modusTooltipCss;

const ModusTooltip = /*@__PURE__*/ proxyCustomElement(class ModusTooltip extends HTMLElement {
    constructor() {
        super();
        this.__registerHost();
        this.__attachShadow();
        this.showEvents = ['mouseenter', 'mouseover', 'focus'];
        this.hideEvents = ['mouseleave', 'blur', 'click'];
        this.showEventsListener = () => {
            window.clearTimeout(this.hoverTimer);
            this.hoverTimer = window.setTimeout(() => {
                this.show();
            }, 500);
        };
        this.hideEventsListener = () => {
            this.hide();
            window.clearTimeout(this.hoverTimer);
            this.hoverTimer = undefined;
        };
        this.ariaLabel = undefined;
        this.position = 'top';
        this.text = undefined;
        this.disabled = undefined;
    }
    handlePositionChange(newValue) {
        if (this.popperInstance) {
            this.popperInstance.setOptions((options) => (Object.assign(Object.assign({}, options), { placement: newValue, modifiers: [...options.modifiers] })));
        }
        else
            this.initializePopper(newValue);
    }
    onTextChange(newValue) {
        if ((newValue === null || newValue === void 0 ? void 0 : newValue.length) > 1) {
            this.initializePopper(this.position);
        }
        else {
            this.cleanupPopper();
        }
    }
    onDisabledChange(newValue) {
        if (!newValue) {
            this.initializePopper(this.position);
        }
        else {
            this.cleanupPopper();
        }
    }
    attachEventListeners() {
        const target = this.element.firstElementChild;
        if (!target)
            return;
        this.showEvents.forEach((event) => {
            target.addEventListener(event, this.showEventsListener);
        });
        this.hideEvents.forEach((event) => {
            target.addEventListener(event, this.hideEventsListener);
        });
    }
    componentDidLoad() {
        this.tooltipElement = this.element.shadowRoot.querySelector('.tooltip');
        this.attachEventListeners();
    }
    disconnectedCallback() {
        this.cleanupPopper();
        window.clearTimeout(this.hoverTimer);
    }
    initializePopper(position) {
        if (this.popperInstance) {
            this.cleanupPopper();
        }
        const target = this.element.firstElementChild;
        if (!target || !this.tooltipElement)
            return;
        this.popperInstance = createPopper(target, this.tooltipElement, {
            placement: position,
            modifiers: [
                {
                    name: 'offset',
                    options: {
                        offset: [0, 8],
                    },
                },
            ],
        });
        this.showEvents.forEach((event) => {
            target.addEventListener(event, this.showEventsListener);
        });
        this.hideEvents.forEach((event) => {
            target.addEventListener(event, this.hideEventsListener);
        });
    }
    cleanupPopper() {
        var _a;
        const target = this.element.firstElementChild;
        if (target) {
            this.showEvents.forEach((event) => {
                target.removeEventListener(event, this.showEventsListener);
            });
            this.hideEvents.forEach((event) => {
                target.removeEventListener(event, this.hideEventsListener);
            });
        }
        (_a = this.popperInstance) === null || _a === void 0 ? void 0 : _a.destroy();
        this.popperInstance = null;
    }
    show() {
        var _a;
        if (!this.popperInstance && ((_a = this.text) === null || _a === void 0 ? void 0 : _a.length) > 1 && !this.disabled) {
            this.initializePopper(this.position);
        }
        if (this.popperInstance) {
            // Make the tooltip visible
            this.tooltipElement.setAttribute('data-show', '');
            // Enable the event listeners
            this.popperInstance.setOptions((options) => (Object.assign(Object.assign({}, options), { modifiers: [...options.modifiers, { name: 'eventListeners', enabled: true }] })));
            // Update its position
            this.popperInstance.update();
        }
    }
    hide() {
        if (this.popperInstance) {
            // Hide the tooltip
            this.tooltipElement.removeAttribute('data-show');
            // Disable the event listeners
            this.popperInstance.setOptions((options) => (Object.assign(Object.assign({}, options), { modifiers: [...options.modifiers, { name: 'eventListeners', enabled: false }] })));
        }
    }
    render() {
        var _a;
        const hidden = this.disabled || !(((_a = this.text) === null || _a === void 0 ? void 0 : _a.length) > 1);
        return (h(Fragment, { key: 'a0ee64cbe91faed93adc2596116b7ea92f3b6979' }, h("slot", { key: '8b53b82a61a67bf958b8d18402c9ecc0d64f95ee' }), h("div", { key: '3a707f878d56c961636010aa06d65c132f360790', tabIndex: -1, class: { tooltip: true, hide: hidden }, "aria-label": this.ariaLabel || undefined, role: "tooltip" }, this.text, h("div", { key: '14b0ae5148bc13345df0732eeb299354ce7e3ae4', id: "arrow", "data-popper-arrow": true }))));
    }
    get element() { return this; }
    static get watchers() { return {
        "position": ["handlePositionChange"],
        "text": ["onTextChange"],
        "disabled": ["onDisabledChange"]
    }; }
    static get style() { return ModusTooltipStyle0; }
}, [1, "modus-tooltip", {
        "ariaLabel": [1, "aria-label"],
        "position": [1],
        "text": [1],
        "disabled": [4]
    }, undefined, {
        "position": ["handlePositionChange"],
        "text": ["onTextChange"],
        "disabled": ["onDisabledChange"]
    }]);
function defineCustomElement() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = ["modus-tooltip"];
    components.forEach(tagName => { switch (tagName) {
        case "modus-tooltip":
            if (!customElements.get(tagName)) {
                customElements.define(tagName, ModusTooltip);
            }
            break;
    } });
}

export { ModusTooltip as M, defineCustomElement as d };
