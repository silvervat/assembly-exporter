import { proxyCustomElement, HTMLElement, h, Host } from '@stencil/core/internal/client';
import { v as CELL_EDIT_TYPE_TEXT, w as CELL_EDIT_TYPE_INT, x as CELL_EDIT_TYPE_DATE, y as CELL_EDIT_TYPE_AUTOCOMPLETE, z as CELL_EDIT_TYPE_SELECT, A as KEYBOARD_UP, B as KEYBOARD_DOWN, g as KEYBOARD_ENTER } from './modus-table.constants.js';
import { d as defineCustomElement$7 } from './modus-autocomplete2.js';
import { d as defineCustomElement$6 } from './modus-chip2.js';
import { d as defineCustomElement$5 } from './modus-date-input2.js';
import { d as defineCustomElement$4 } from './modus-date-picker2.js';
import { d as defineCustomElement$3 } from './modus-number-input2.js';
import { d as defineCustomElement$2 } from './modus-select2.js';
import { d as defineCustomElement$1 } from './modus-text-input2.js';
import { c as createPopper } from './popper.js';

const modusTableCellEditorCss = "@import url(\"https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700\");:host{--modus-autocomplete-border:none;--modus-autocomplete-border-active:none;--modus-autocomplete-font-size:14px;--modus-input-border-color:none}.editor::part(input-container),.editor::part(input){height:2.9375rem !important}table.density-comfortable .editor::part(input-container),table.density-comfortable .editor::part(input){height:1.75rem !important}table.density-compact .editor::part(input-container),table.density-compact .editor::part(input){height:1.25rem !important}.autocomplete-container{margin-left:4px;margin-top:5px}.editor::part(sub-text){display:none}.date-picker-container::part(date-inputs){align-items:center;display:flex;justify-content:center}.editor::part(input-container){border:2px solid var(--modus-input-border-active-color, #217cbb);border-radius:unset;z-index:99}.editor::part(input-container error){border:2px solid var(--modus-input-validation-error-color, #da212c);border-radius:unset;z-index:99}.error-tooltip{background-color:var(--modus-input-validation-error-color, #da212c);border-radius:2px;color:#fff;display:none;font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";font-size:12px;font-weight:600;letter-spacing:0.005em;line-height:15px;max-width:200px;padding:5px 8px;text-align:left;word-wrap:break-word;z-index:10}";
const ModusTableCellEditorStyle0 = modusTableCellEditorCss;

var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const ModusTableCellEditor = /*@__PURE__*/ proxyCustomElement(class ModusTableCellEditor extends HTMLElement {
    constructor() {
        super();
        this.__registerHost();
        this.handleBlur = () => {
            this.valueChange(this.editedValue);
            this.destroyErrorTooltip();
        };
        this.handleKeyDown = (e) => {
            this.keyDown(e, this.editedValue);
        };
        this.handleError = (e) => {
            this.errorMessage = e.detail;
            this.showErrorTooltip();
        };
        this.getDefaultProps = (ariaLabel) => ({
            'aria-label': ariaLabel,
            class: 'editor',
            ref: (ref) => (this.inputElement = ref),
        });
        this.args = undefined;
        this.dataType = undefined;
        this.value = undefined;
        this.type = undefined;
        this.valueChange = undefined;
        this.keyDown = undefined;
        this.errorMessage = undefined;
    }
    connectedCallback() {
        this.editedValue = this.value;
    }
    componentDidLoad() {
        if (this.inputElement['focusInput']) {
            this.inputElement['focusInput']();
        }
        this.createErrorTooltip();
    }
    disconnectedCallback() {
        this.destroyErrorTooltip();
    }
    handleDocumentClick(event) {
        if (this.type != 'date') {
            return;
        }
        const target = event.target;
        if (!this.inputElement.contains(target)) {
            this.handleBlur();
        }
    }
    createErrorTooltip() {
        if (!this.errorTooltip) {
            this.errorTooltip = document.createElement('div');
            this.errorTooltip.className = 'error-tooltip';
            this.inputElement.getRootNode().appendChild(this.errorTooltip); // Append to the same parent element as input
            this.popperInstance = createPopper(this.inputElement, this.errorTooltip, {
                placement: 'bottom-start',
                modifiers: [
                    {
                        name: 'offset',
                        options: {
                            offset: [-0.5, 0], // Offset from the element
                        },
                    },
                    {
                        name: 'preventOverflow',
                        options: {
                            boundary: 'viewport', // Prevents tooltip from overflowing the viewport
                        },
                    },
                ],
            });
        }
    }
    showErrorTooltip() {
        if (this.errorTooltip) {
            this.errorTooltip.innerText = this.errorMessage;
            this.errorTooltip.style.display = 'block';
            if (this.popperInstance) {
                this.popperInstance.update();
            }
        }
    }
    hideErrorTooltip() {
        if (this.errorTooltip) {
            this.errorTooltip.style.display = 'none';
        }
    }
    destroyErrorTooltip() {
        if (this.popperInstance) {
            this.popperInstance.destroy();
            this.popperInstance = null;
        }
        if (this.errorTooltip) {
            this.errorTooltip.remove();
            this.errorTooltip = null;
        }
    }
    renderNumberInput() {
        function handleArrowKeys(e, callback) {
            const code = e.key.toLowerCase();
            if (code === KEYBOARD_UP || code === KEYBOARD_DOWN) {
                e.stopPropagation();
            }
            else
                callback(e);
        }
        return (h("modus-number-input", Object.assign({}, this.getDefaultProps('Number input'), { value: this.value, textAlign: "right", size: "large", onBlur: this.handleBlur, onValueChange: (e) => (this.editedValue = e.detail), onKeyDown: (e) => handleArrowKeys(e, this.handleKeyDown) })));
    }
    renderTextInput() {
        return (h("modus-text-input", Object.assign({}, this.getDefaultProps('Text input'), { value: this.value, onValueChange: (e) => (this.editedValue = e.detail), onBlur: this.handleBlur, onKeyDown: this.handleKeyDown, autoFocusInput: true, size: "large" })));
    }
    renderSelectInput() {
        const valueKey = 'display';
        const args = this.args;
        const options = (args === null || args === void 0 ? void 0 : args.options) || [];
        const optionsDisplayProp = (args === null || args === void 0 ? void 0 : args.optionsDisplayProp) || valueKey;
        const placeholder = args === null || args === void 0 ? void 0 : args.placeholder;
        const selectedOption = options.find((option) => option[optionsDisplayProp] === this.value);
        function handleEnter(e, callback) {
            const code = e.key.toLowerCase();
            if (code === KEYBOARD_ENTER) {
                e.stopPropagation();
            }
            else
                callback(e);
        }
        return (h("div", null, h("modus-select", Object.assign({}, this.getDefaultProps('Select input'), { value: selectedOption, "options-display-prop": optionsDisplayProp, size: "large", options: options, placeholder: placeholder, onInputBlur: this.handleBlur, onKeyDown: (e) => handleEnter(e, this.handleKeyDown), onValueChange: (e) => {
                const detail = e.detail;
                if (this.dataType === 'badge') {
                    const { display } = detail, restProps = __rest(detail, ["display"]);
                    this.editedValue = Object.assign(Object.assign({}, restProps), { text: display });
                }
                else if (this.dataType === 'link') {
                    this.editedValue = detail;
                }
                else {
                    this.editedValue = detail[valueKey];
                }
            } }))));
    }
    renderDateInput() {
        var _a;
        const valueKey = 'value';
        const format = (_a = this.args) === null || _a === void 0 ? void 0 : _a.format;
        return (h("modus-date-picker", { onBlur: this.handleBlur, onClick: (e) => e.stopPropagation(), class: "date-picker-container" }, h("modus-date-input", Object.assign({}, this.getDefaultProps('Date input'), { format: format, size: "large", "show-calendar-icon": "true", value: this.value, onValueChange: (e) => {
                this.editedValue = e.detail[valueKey];
                this.hideErrorTooltip();
            }, onValueError: (e) => this.handleError(e) }))));
    }
    renderAutocompleteInput() {
        var _a, _b;
        const args = this.args;
        let options = [];
        let selectedOption = '';
        if (this.dataType === 'badge') {
            options = args === null || args === void 0 ? void 0 : args.options.map((option) => option.text);
            selectedOption = ((_a = this.value) === null || _a === void 0 ? void 0 : _a.text) || '';
        }
        else if (this.dataType === 'link') {
            options = args === null || args === void 0 ? void 0 : args.options.map((option) => option.display);
            selectedOption = ((_b = this.value) === null || _b === void 0 ? void 0 : _b.display) || '';
        }
        else {
            options = ((args === null || args === void 0 ? void 0 : args.options) || []);
            selectedOption = this.editedValue;
        }
        return (h("div", { class: "autocomplete-container" }, h("modus-autocomplete", Object.assign({}, this.getDefaultProps('Autocomplete input'), { "include-search-icon": "false", size: "medium", options: options, onBlur: this.handleBlur, onKeyDown: (e) => e.stopPropagation(), onOptionSelected: (e) => {
                const selectedDetail = e.detail;
                if (this.dataType === 'badge') {
                    const selectedOption = args === null || args === void 0 ? void 0 : args.options.find((option) => option.text === selectedDetail);
                    this.editedValue = selectedOption;
                }
                else if (this.dataType === 'link') {
                    const selectedOption = args === null || args === void 0 ? void 0 : args.options.find((option) => option.display === selectedDetail);
                    this.editedValue = selectedOption;
                }
                else {
                    this.editedValue = selectedDetail;
                }
            }, value: selectedOption }))));
    }
    renderEditor() {
        switch (this.type) {
            case CELL_EDIT_TYPE_SELECT:
                return this.renderSelectInput();
            case CELL_EDIT_TYPE_AUTOCOMPLETE:
                return this.renderAutocompleteInput();
            case CELL_EDIT_TYPE_DATE:
                return this.renderDateInput();
            case CELL_EDIT_TYPE_INT:
                return this.renderNumberInput();
            case CELL_EDIT_TYPE_TEXT:
            default:
                return this.renderTextInput();
        }
    }
    render() {
        return h(Host, { key: '27197918d3cbb8d084d13c51c3ec4be2ae27038d' }, this.renderEditor());
    }
    static get style() { return ModusTableCellEditorStyle0; }
}, [0, "modus-table-cell-editor", {
        "args": [16],
        "dataType": [1, "data-type"],
        "value": [16],
        "type": [1],
        "valueChange": [16],
        "keyDown": [16],
        "errorMessage": [32]
    }, [[4, "click", "handleDocumentClick"]]]);
function defineCustomElement() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = ["modus-table-cell-editor", "modus-autocomplete", "modus-chip", "modus-date-input", "modus-date-picker", "modus-number-input", "modus-select", "modus-text-input"];
    components.forEach(tagName => { switch (tagName) {
        case "modus-table-cell-editor":
            if (!customElements.get(tagName)) {
                customElements.define(tagName, ModusTableCellEditor);
            }
            break;
        case "modus-autocomplete":
            if (!customElements.get(tagName)) {
                defineCustomElement$7();
            }
            break;
        case "modus-chip":
            if (!customElements.get(tagName)) {
                defineCustomElement$6();
            }
            break;
        case "modus-date-input":
            if (!customElements.get(tagName)) {
                defineCustomElement$5();
            }
            break;
        case "modus-date-picker":
            if (!customElements.get(tagName)) {
                defineCustomElement$4();
            }
            break;
        case "modus-number-input":
            if (!customElements.get(tagName)) {
                defineCustomElement$3();
            }
            break;
        case "modus-select":
            if (!customElements.get(tagName)) {
                defineCustomElement$2();
            }
            break;
        case "modus-text-input":
            if (!customElements.get(tagName)) {
                defineCustomElement$1();
            }
            break;
    } });
}

export { ModusTableCellEditor as M, defineCustomElement as d };
