import { proxyCustomElement, HTMLElement, createEvent, h } from '@stencil/core/internal/client';
import { a as IconChevronLeft, I as IconChevronRight } from './IconChevronRight.js';

var PaginationDirection;
(function (PaginationDirection) {
    PaginationDirection["Previous"] = "Previous";
    PaginationDirection["Next"] = "Next";
})(PaginationDirection || (PaginationDirection = {}));

const modusPaginationCss = "@import url(\"https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700\");nav{align-items:center;background-color:transparent;border-radius:0.25rem;color:var(--modus-pagination-color, #252a2e);display:inline-flex;font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";justify-content:center;width:100%}nav svg path{fill:var(--modus-pagination-chevron-color, #6a6e79)}nav ul{align-items:center;display:flex;flex-direction:row;justify-content:center;padding:0}nav ul li{list-style-type:none;user-select:none}nav ul li button{align-items:center;background-color:transparent;border:unset;border-radius:0.25rem;color:#252a2e;display:flex;font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";justify-content:center}nav ul li button.active{background-color:var(--modus-pagination-active-bg, #dcedf9);color:var(--modus-pagination-active-color, #217cbb);outline:1px solid transparent}nav ul li button.disabled{opacity:0.3}nav ul li button.hoverable{cursor:pointer}nav ul li button.hoverable:not(.active):hover{background-color:var(--modus-pagination-hover-bg, #e0e1e9)}nav.small{height:1.5rem}nav.small ul li button{font-size:0.75rem;height:1.5rem;padding:0 0.5rem}nav.small ul li button[aria-label=Next],nav.small ul li button[aria-label=Previous]{padding-left:0.25rem;padding-right:0.25rem}nav.medium{height:2rem}nav.medium ul li button{font-size:0.875rem;height:2rem;padding:0 0.75rem}nav.medium ul li button[aria-label=Next],nav.medium ul li button[aria-label=Previous]{padding-left:0.375rem;padding-right:0.375rem}nav.large{height:3rem}nav.large ul li button{font-size:1.25rem;height:3rem;padding:0 1.125rem}nav.large ul li button[aria-label=Next],nav.large ul li button[aria-label=Previous]{padding-left:0.75rem;padding-right:0.75rem}";
const ModusPaginationStyle0 = modusPaginationCss;

const ModusPagination = /*@__PURE__*/ proxyCustomElement(class ModusPagination extends HTMLElement {
    activePageWatch(newValue, oldValue) {
        if (newValue !== oldValue) {
            this.pageChange.emit(newValue);
        }
    }
    constructor() {
        super();
        this.__registerHost();
        this.__attachShadow();
        this.pageChange = createEvent(this, "pageChange", 7);
        this.chevronSizeBySize = new Map([
            ['small', '16'],
            ['medium', '20'],
            ['large', '24'],
        ]);
        this.classBySize = new Map([
            ['small', 'small'],
            ['medium', 'medium'],
            ['large', 'large'],
        ]);
        this.ariaLabel = undefined;
        this.activePage = 1;
        this.maxPage = undefined;
        this.minPage = undefined;
        this.prevPageButtonText = undefined;
        this.nextPageButtonText = undefined;
        this.size = 'medium';
        this.pages = undefined;
        this.setPages();
    }
    componentWillRender() {
        if (this.activePage === undefined || isNaN(this.activePage)) {
            this.activePage = 1;
        }
        this.setPages();
    }
    setPages() {
        const pages = [];
        const ellipsis = '...';
        // Always show the first page.
        this.maxPage > 1 && pages.push(this.minPage);
        if (this.maxPage - this.minPage < 7) {
            // No need for ellipsis for 7 pages - push all of them.
            for (let i = this.minPage + 1; i < this.maxPage; i++) {
                pages.push(i);
            }
        }
        else {
            if (this.activePage - this.minPage < 4) {
                // One of the first 4 pages is active.
                [1, 2, 3, 4].map((val) => pages.push(this.minPage + val));
                pages.push(ellipsis);
            }
            else if (this.maxPage - this.activePage < 4) {
                // One of the last 4 pages is active.
                pages.push(ellipsis);
                [4, 3, 2, 1].map((val) => pages.push(this.maxPage - val));
            }
            else {
                // The active page is somewhere in the middle.
                pages.push(ellipsis);
                [-1, 0, 1].map((val) => pages.push(this.activePage + val));
                pages.push(ellipsis);
            }
        }
        // Always show the last page.
        pages.push(this.maxPage);
        this.pages = pages;
    }
    handleChevronClick(direction) {
        if (direction === PaginationDirection.Previous && this.activePage !== this.minPage) {
            this.activePage--;
        }
        else if (direction === PaginationDirection.Next && this.activePage !== this.maxPage) {
            this.activePage++;
        }
    }
    handleChevronKeydown(event, direction) {
        if (event.key.toLowerCase() === 'enter') {
            this.handleChevronClick(direction);
            event.preventDefault();
        }
    }
    handlePageKeydown(event, page) {
        if (event.key.toLowerCase() === 'enter') {
            this.handlePageClick(page);
            event.preventDefault();
        }
    }
    handlePageClick(page) {
        if (!isNaN(page)) {
            this.activePage = page;
        }
    }
    renderPreviousPageControl() {
        return (this.maxPage - this.minPage >= 7 && (h("li", null, h("button", { "aria-label": "Previous", class: `${this.activePage != this.minPage ? 'hoverable' : 'disabled'}`, disabled: this.activePage === this.minPage, onClick: () => this.handleChevronClick(PaginationDirection.Previous), onKeyDown: (event) => this.handleChevronKeydown(event, PaginationDirection.Previous) }, this.prevPageButtonText ? (h("span", { "data-test-id": "prev-button-text" }, this.prevPageButtonText)) : (h(IconChevronLeft, { size: this.chevronSizeBySize.get(this.size) }))))));
    }
    renderNextPageControl() {
        return (this.maxPage - this.minPage >= 7 && (h("li", null, h("button", { "aria-label": "Next", class: `${this.activePage != this.maxPage ? 'hoverable' : 'disabled'}`, disabled: this.activePage === this.maxPage, onClick: () => this.handleChevronClick(PaginationDirection.Next), onKeyDown: (event) => this.handleChevronKeydown(event, PaginationDirection.Next) }, this.nextPageButtonText ? (h("span", { "data-test-id": "next-button-text" }, this.nextPageButtonText)) : (h(IconChevronRight, { size: this.chevronSizeBySize.get(this.size) }))))));
    }
    renderPageNumbers() {
        return this.pages.map((page) => {
            const isCurrentPage = page === this.activePage;
            if (page === '...') {
                return (h("li", null, h("button", { class: `${!isNaN(+page) ? 'hoverable' : ''}`, tabIndex: -1 }, page)));
            }
            return (h("li", null, h("button", { "aria-current": isCurrentPage ? 'page' : null, class: `${page === this.activePage ? 'active' : ''} ${!isNaN(+page) ? 'hoverable' : ''}`, onClick: () => this.handlePageClick(+page), onKeyDown: (event) => this.handlePageKeydown(event, +page) }, page)));
        });
    }
    render() {
        return (h("nav", { key: '74cddfd08be69283bb88db957497ed88f4593906', "aria-label": this.ariaLabel || undefined, class: `${this.classBySize.get(this.size)}` }, h("ul", { key: '892927c0a9a450e2678db22809454830023963c7' }, this.renderPreviousPageControl(), this.renderPageNumbers(), this.renderNextPageControl())));
    }
    static get watchers() { return {
        "activePage": ["activePageWatch"]
    }; }
    static get style() { return ModusPaginationStyle0; }
}, [1, "modus-pagination", {
        "ariaLabel": [1, "aria-label"],
        "activePage": [1026, "active-page"],
        "maxPage": [2, "max-page"],
        "minPage": [2, "min-page"],
        "prevPageButtonText": [1, "prev-page-button-text"],
        "nextPageButtonText": [1, "next-page-button-text"],
        "size": [1],
        "pages": [32]
    }, undefined, {
        "activePage": ["activePageWatch"]
    }]);
function defineCustomElement() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = ["modus-pagination"];
    components.forEach(tagName => { switch (tagName) {
        case "modus-pagination":
            if (!customElements.get(tagName)) {
                customElements.define(tagName, ModusPagination);
            }
            break;
    } });
}

export { ModusPagination as M, defineCustomElement as d };
