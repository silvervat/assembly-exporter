// eslint-disable-next-line
import { Fragment, h } from "@stencil/core";
import { createPopper } from "@popperjs/core";
export class ModusTooltip {
    constructor() {
        this.showEvents = ['mouseenter', 'mouseover', 'focus'];
        this.hideEvents = ['mouseleave', 'blur', 'click'];
        this.showEventsListener = () => {
            window.clearTimeout(this.hoverTimer);
            this.hoverTimer = window.setTimeout(() => {
                this.show();
            }, 500);
        };
        this.hideEventsListener = () => {
            this.hide();
            window.clearTimeout(this.hoverTimer);
            this.hoverTimer = undefined;
        };
        this.ariaLabel = undefined;
        this.position = 'top';
        this.text = undefined;
        this.disabled = undefined;
    }
    handlePositionChange(newValue) {
        if (this.popperInstance) {
            this.popperInstance.setOptions((options) => (Object.assign(Object.assign({}, options), { placement: newValue, modifiers: [...options.modifiers] })));
        }
        else
            this.initializePopper(newValue);
    }
    onTextChange(newValue) {
        if ((newValue === null || newValue === void 0 ? void 0 : newValue.length) > 1) {
            this.initializePopper(this.position);
        }
        else {
            this.cleanupPopper();
        }
    }
    onDisabledChange(newValue) {
        if (!newValue) {
            this.initializePopper(this.position);
        }
        else {
            this.cleanupPopper();
        }
    }
    attachEventListeners() {
        const target = this.element.firstElementChild;
        if (!target)
            return;
        this.showEvents.forEach((event) => {
            target.addEventListener(event, this.showEventsListener);
        });
        this.hideEvents.forEach((event) => {
            target.addEventListener(event, this.hideEventsListener);
        });
    }
    componentDidLoad() {
        this.tooltipElement = this.element.shadowRoot.querySelector('.tooltip');
        this.attachEventListeners();
    }
    disconnectedCallback() {
        this.cleanupPopper();
        window.clearTimeout(this.hoverTimer);
    }
    initializePopper(position) {
        if (this.popperInstance) {
            this.cleanupPopper();
        }
        const target = this.element.firstElementChild;
        if (!target || !this.tooltipElement)
            return;
        this.popperInstance = createPopper(target, this.tooltipElement, {
            placement: position,
            modifiers: [
                {
                    name: 'offset',
                    options: {
                        offset: [0, 8],
                    },
                },
            ],
        });
        this.showEvents.forEach((event) => {
            target.addEventListener(event, this.showEventsListener);
        });
        this.hideEvents.forEach((event) => {
            target.addEventListener(event, this.hideEventsListener);
        });
    }
    cleanupPopper() {
        var _a;
        const target = this.element.firstElementChild;
        if (target) {
            this.showEvents.forEach((event) => {
                target.removeEventListener(event, this.showEventsListener);
            });
            this.hideEvents.forEach((event) => {
                target.removeEventListener(event, this.hideEventsListener);
            });
        }
        (_a = this.popperInstance) === null || _a === void 0 ? void 0 : _a.destroy();
        this.popperInstance = null;
    }
    show() {
        var _a;
        if (!this.popperInstance && ((_a = this.text) === null || _a === void 0 ? void 0 : _a.length) > 1 && !this.disabled) {
            this.initializePopper(this.position);
        }
        if (this.popperInstance) {
            // Make the tooltip visible
            this.tooltipElement.setAttribute('data-show', '');
            // Enable the event listeners
            this.popperInstance.setOptions((options) => (Object.assign(Object.assign({}, options), { modifiers: [...options.modifiers, { name: 'eventListeners', enabled: true }] })));
            // Update its position
            this.popperInstance.update();
        }
    }
    hide() {
        if (this.popperInstance) {
            // Hide the tooltip
            this.tooltipElement.removeAttribute('data-show');
            // Disable the event listeners
            this.popperInstance.setOptions((options) => (Object.assign(Object.assign({}, options), { modifiers: [...options.modifiers, { name: 'eventListeners', enabled: false }] })));
        }
    }
    render() {
        var _a;
        const hidden = this.disabled || !(((_a = this.text) === null || _a === void 0 ? void 0 : _a.length) > 1);
        return (h(Fragment, { key: 'a0ee64cbe91faed93adc2596116b7ea92f3b6979' }, h("slot", { key: '8b53b82a61a67bf958b8d18402c9ecc0d64f95ee' }), h("div", { key: '3a707f878d56c961636010aa06d65c132f360790', tabIndex: -1, class: { tooltip: true, hide: hidden }, "aria-label": this.ariaLabel || undefined, role: "tooltip" }, this.text, h("div", { key: '14b0ae5148bc13345df0732eeb299354ce7e3ae4', id: "arrow", "data-popper-arrow": true }))));
    }
    static get is() { return "modus-tooltip"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["modus-tooltip.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["modus-tooltip.css"]
        };
    }
    static get properties() {
        return {
            "ariaLabel": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string | null",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "(optional) The tooltip's aria-label."
                },
                "attribute": "aria-label",
                "reflect": false
            },
            "position": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "ModusToolTipPlacement",
                    "resolved": "\"auto\" | \"bottom\" | \"left\" | \"right\" | \"top\"",
                    "references": {
                        "ModusToolTipPlacement": {
                            "location": "import",
                            "path": "./modus-tooltip.models",
                            "id": "src/components/modus-tooltip/modus-tooltip.models.ts::ModusToolTipPlacement"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "(optional) The tooltip's position relative to its content."
                },
                "attribute": "position",
                "reflect": false,
                "defaultValue": "'top'"
            },
            "text": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The tooltip's text."
                },
                "attribute": "text",
                "reflect": false
            },
            "disabled": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Hide the tooltip"
                },
                "attribute": "disabled",
                "reflect": false
            }
        };
    }
    static get elementRef() { return "element"; }
    static get watchers() {
        return [{
                "propName": "position",
                "methodName": "handlePositionChange"
            }, {
                "propName": "text",
                "methodName": "onTextChange"
            }, {
                "propName": "disabled",
                "methodName": "onDisabledChange"
            }];
    }
}
