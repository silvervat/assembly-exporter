import { h, // eslint-disable-line @typescript-eslint/no-unused-vars
 } from "@stencil/core";
import { ModusIconMap } from "../../icons/ModusIconMap";
import ModusDatePickerCalendar from "./utils/modus-date-picker.calendar";
import ModusDatePickerState from "./utils/modus-date-picker.state";
export class ModusDatePicker {
    constructor() {
        this._dateInputs = {};
        this._locale = 'default';
        this.isInvalidDateRange = (startDate, endDate) => this.compare(endDate, startDate) < 0;
        this.label = undefined;
        this._forceUpdate = {};
        this._showCalendar = false;
        this._showYearArrows = false;
    }
    get _currentInput() {
        return Object.values(this._dateInputs).find((dt) => dt.isCalendarOpen());
    }
    componentWillLoad() {
        this._calendar = new ModusDatePickerCalendar();
    }
    /** Handlers */
    handleCalendarIconClick(event) {
        const { type } = event.detail;
        Object.keys(this._dateInputs).forEach((d) => this._dateInputs[d].toggleCalendar(d === type ? null : false));
        this.toggleCalendar();
        if (this._showCalendar) {
            this.gotoDateBeingPicked(this._dateInputs[type].getDate());
        }
        this.forceUpdate();
    }
    handleClickOutside(event) {
        if (this.element.contains(event.target) || event.defaultPrevented) {
            return;
        }
        // Collapse when clicked outside
        this.toggleCalendar(false);
    }
    handleDateInputValue(event) {
        const { type } = event.detail;
        if (!this._dateInputs[type])
            return;
        this._dateInputs[type].refresh();
        if (this._showCalendar) {
            this.gotoDateBeingPicked(this._dateInputs[type].getDate());
        }
        this.forceUpdate();
    }
    handleDateInputBlur() {
        var _a, _b;
        this.applyDateRangeRules((_a = this._dateInputs['start']) === null || _a === void 0 ? void 0 : _a.getDate(), (_b = this._dateInputs['end']) === null || _b === void 0 ? void 0 : _b.getDate());
    }
    handleSlotChange() {
        const dates = Array.from(this.element.querySelectorAll('modus-date-input'));
        dates === null || dates === void 0 ? void 0 : dates.forEach((d) => {
            this._dateInputs[d.type] = new ModusDatePickerState(d);
        });
    }
    /** Helpers */
    addMonthOffset(offset) {
        this._calendar.addMonthOffset(offset);
        this.forceUpdate();
    }
    addYearOffset(offset) {
        this._calendar.addYearOffset(offset);
        this.forceUpdate();
    }
    applyDateRangeRules(startDate, endDate) {
        if (!startDate || !endDate) {
            return;
        }
        if (this.isInvalidDateRange(startDate, endDate)) {
            this._dateInputs['start'].setError('Invalid date range');
            this._dateInputs['end'].setError();
        }
        else {
            this._dateInputs['start'].validateInput();
            this._dateInputs['end'].validateInput();
        }
    }
    compare(date1, date2) {
        if (!date1 && !date2) {
            return 0;
        }
        else if (!date1 && date2) {
            return -1;
        }
        else if (date1 && !date2) {
            return 1;
        }
        let delta;
        delta = date1.getFullYear() - date2.getFullYear();
        if (delta !== 0) {
            return delta;
        }
        delta = date1.getMonth() - date2.getMonth();
        if (delta !== 0) {
            return delta;
        }
        return date1.getDate() - date2.getDate();
    }
    forceUpdate() {
        this._forceUpdate = Object.assign({}, this._forceUpdate);
    }
    findDatePositionsInARange(date, startDate, endDate) {
        return {
            start: startDate && this.compare(date, startDate) === 0,
            end: endDate && this.compare(date, endDate) === 0,
            'in-range': startDate && endDate && this.compare(date, startDate) > 0 && this.compare(date, endDate) < 0,
        };
    }
    gotoDateBeingPicked(pickedDate) {
        if (!this._showCalendar) {
            return;
        }
        const date = pickedDate || new Date();
        this._calendar.gotoDate(date.getFullYear(), date.getMonth());
    }
    goToNearestBoundaryDate(date) {
        var _a, _b;
        const minDate = (_a = this._currentInput) === null || _a === void 0 ? void 0 : _a.getMinDateAllowed();
        const maxDate = (_b = this._currentInput) === null || _b === void 0 ? void 0 : _b.getMaxDateAllowed();
        const targetDate = this.compare(date, minDate) < 0 ? minDate : maxDate;
        this.gotoDateBeingPicked(targetDate);
        this.forceUpdate();
    }
    pickCalendarDate(date) {
        this._currentInput.setDate(date);
        this.toggleCalendar(false);
    }
    showYearChange(show = true) {
        this._showYearArrows = show;
    }
    isWithinCurrentMinMax(date) {
        var _a, _b;
        const max = (_a = this._currentInput) === null || _a === void 0 ? void 0 : _a.getMaxDateAllowed();
        const min = (_b = this._currentInput) === null || _b === void 0 ? void 0 : _b.getMinDateAllowed();
        if (!date) {
            return false;
        }
        if (min && this.compare(date, min) < 0) {
            return false;
        }
        if (max && this.compare(date, max) > 0) {
            return false;
        }
        return true;
    }
    toggleCalendar(val = null) {
        if (val !== null) {
            this._showCalendar = val;
            if (!this._showCalendar) {
                Object.keys(this._dateInputs || {}).forEach((d) => {
                    this._dateInputs[d].toggleCalendar(false);
                });
            }
        }
        else {
            this._showCalendar = !!Object.values(this._dateInputs).find((dt) => dt.isCalendarOpen());
        }
    }
    renderCalendarBody() {
        var _a, _b, _c, _d;
        const today = new Date();
        const startDate = (_a = this._dateInputs['start']) === null || _a === void 0 ? void 0 : _a.getDate();
        const endDate = (_b = this._dateInputs['end']) === null || _b === void 0 ? void 0 : _b.getDate();
        const singleDate = (_c = this._dateInputs['single']) === null || _c === void 0 ? void 0 : _c.getDate();
        // Get day of the week and prepare blank cells to render the calendar dates properly
        const firstDay = (_d = new Date(this._calendar.selectedYear, this._calendar.selectedMonth)) === null || _d === void 0 ? void 0 : _d.getDay();
        const blankDatesArr = new Array(firstDay).fill(0);
        return (h("div", { class: "calendar-body" }, h("div", { class: "calendar-days-week grid" }, this._calendar.getDaysOfWeek(this._locale).map((d) => {
            return h("div", { class: "grid-item" }, d);
        })), h("div", { class: "calendar-month-container" }, h("div", { class: {
                'calendar-month grid': true,
                'invalid-date-range': this.isInvalidDateRange(startDate, endDate),
            } }, blankDatesArr &&
            blankDatesArr.length > 0 &&
            blankDatesArr.map(() => {
                return (h("button", { class: {
                        'calendar-day grid-item': false,
                        disabled: true,
                    }, disabled: true, tabIndex: -1 }, "\u00A0"));
            }), this._calendar.dates.map((date, index) => {
            if (!date) {
                return null;
            }
            const positions = this.findDatePositionsInARange(date, startDate, endDate);
            const isStartDate = positions['start'];
            const isEndDate = positions['end'];
            const isToday = this.compare(date, today) === 0;
            const isSingleDateSelected = singleDate && this.compare(date, singleDate) === 0;
            const isSelected = isStartDate || isEndDate || isSingleDateSelected;
            const isInRange = !isSelected ? positions['in-range'] : false;
            const isDateDisabled = !this.isWithinCurrentMinMax(date);
            // Only for the last date in the calendar
            const onBlurEvent = index === this._calendar.dates.length - 1
                ? {
                    onBlur: () => {
                        this.toggleCalendar(false);
                    },
                }
                : {};
            return (h("button", Object.assign({ class: {
                    'calendar-day grid-item': true,
                    selected: isSelected,
                    disabled: isDateDisabled,
                    start: isStartDate && !isEndDate,
                    end: isEndDate && !isStartDate,
                    'current-day': isToday,
                    'range-selected': isInRange,
                }, disabled: isDateDisabled, tabIndex: 0, type: "button", "aria-current": isSelected ? 'date' : undefined, onClick: () => this.pickCalendarDate(date) }, onBlurEvent), date.getDate()));
        }))), !this.isWithinCurrentMinMax(this._currentInput.getDate()) && (h("div", { class: "out-of-range-notification" }, h("div", null, "The selected date is not available"), h("span", { class: "goto-available-dates", onClick: () => this.goToNearestBoundaryDate(this._currentInput.getDate()) }, "Go to available dates")))));
    }
    renderCalendarHeader() {
        var _a, _b;
        return (h("div", { class: "calendar-header" }, h("button", { type: "button", "aria-label": "Previous Month", onClick: () => this.addMonthOffset(-1) }, h(ModusIconMap, { icon: "chevron_left_bold" })), h("div", { class: "title" }, h("div", { class: "calendar-title", role: "heading" }, `${(_a = this._calendar) === null || _a === void 0 ? void 0 : _a.month} ${(_b = this._calendar) === null || _b === void 0 ? void 0 : _b.year}`), h("div", { class: "year-icons" }, h("button", { type: "button", tabIndex: 0, "aria-label": "Next Year", onClick: () => this.addYearOffset(1), class: "year-up" }, h(ModusIconMap, { icon: "caret_up", size: "16" })), h("button", { type: "button", tabIndex: 0, "aria-label": "Previous Year", onClick: () => this.addYearOffset(-1), class: "year-down" }, h(ModusIconMap, { size: "16", icon: "caret_down" })))), h("button", { type: "button", tabIndex: 0, "aria-label": "Next Month", onClick: () => this.addMonthOffset(1) }, h(ModusIconMap, { icon: "chevron_right_bold" }))));
    }
    render() {
        return (h("div", { key: '45ef27e63b41e4b08a1c084acfc0b9d9d92070e3', class: "modus-date-picker" }, this.label ? h("div", { class: 'label-container' }, this.label ? h("label", null, this.label) : null) : null, h("div", { key: '8db804f8291c99e8be8434d81491769b8e2ff604', class: "date-inputs", part: "date-inputs" }, h("slot", { key: 'b003c1220288f9aa056c1cabc4e17d0c20851631', onSlotchange: () => this.handleSlotChange() })), h("div", { key: '973e68544060a5c9bc74f15ef79e21815eee3ba7', style: { display: 'inline-flex' } }, this._showCalendar && (h("nav", { class: "calendar-container", "aria-label": "Pick a Date" }, this.renderCalendarHeader(), this.renderCalendarBody())))));
    }
    static get is() { return "modus-date-picker"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["modus-date-picker.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["modus-date-picker.css"]
        };
    }
    static get properties() {
        return {
            "label": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "(optional) Label for the field."
                },
                "attribute": "label",
                "reflect": false
            }
        };
    }
    static get states() {
        return {
            "_forceUpdate": {},
            "_showCalendar": {},
            "_showYearArrows": {}
        };
    }
    static get elementRef() { return "element"; }
    static get listeners() {
        return [{
                "name": "calendarIconClicked",
                "method": "handleCalendarIconClick",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "click",
                "method": "handleClickOutside",
                "target": "document",
                "capture": false,
                "passive": false
            }, {
                "name": "valueChange",
                "method": "handleDateInputValue",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "dateInputBlur",
                "method": "handleDateInputBlur",
                "target": undefined,
                "capture": false,
                "passive": false
            }];
    }
}
