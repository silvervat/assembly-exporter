import { KEYBOARD_LEFT, KEYBOARD_RIGHT, KEYBOARD_ENTER, KEYBOARD_ESCAPE, KEYBOARD_TAB, HTML_ATTR_DATA_ACCESSOR_KEY, } from "../modus-table.constants";
export class TableHeaderDragDrop {
    constructor() {
        this.columnOrder = [];
        this.columnReorder = false;
        this.columnResizeEnabled = false;
    }
    setValues(columnOrder, columnReorder, columnResizeEnabled, container, table, itemDragState, frozenColumns) {
        this.columnOrder = columnOrder;
        this.columnReorder = columnReorder;
        this.columnResizeEnabled = columnResizeEnabled;
        this.tableHeaderRowEl = container.shadowRoot.querySelector('thead tr');
        this.table = table;
        this.itemDragState = itemDragState;
        this.frozenColumns = frozenColumns;
    }
    /**
     * Is invoked on drag start, sets itemDragState item. Calculates the position for drag start.
     * Adds drag item to ModusTableDragItem
     */
    handleDragStart(event, draggedColumnId, elementRef, mouseInteracted) {
        this.headersList = [].slice.call(this.tableHeaderRowEl.childNodes); // List of table headers.
        this.frozenColumns.forEach((frozenColumn) => {
            const index = this.headersList.findIndex((header) => header.id === frozenColumn);
            if (index > -1) {
                this.headersList.splice(index, 1);
            }
        });
        this.itemDragState = null;
        const dragContent = elementRef.cloneNode(true);
        let clientX, clientY;
        const currentTarget = event.currentTarget;
        if (mouseInteracted) {
            // For MouseEvent
            clientX = event['clientX'];
            clientY = event['clientY'];
        }
        else {
            // For KeyboardEvent
            const position = elementRef.getBoundingClientRect();
            clientX = position.x + 60;
            clientY = position.y + 30;
        }
        const self = currentTarget;
        this.itemDragState = {
            dragContent,
            translation: { x: clientX, y: clientY },
            draggedColumnId: draggedColumnId,
            width: `${self === null || self === void 0 ? void 0 : self.offsetWidth}px`,
            height: `${self === null || self === void 0 ? void 0 : self.offsetHeight}px`,
            mouseInteracted,
        };
    }
    /**
     * When being dragged over, the function get the element's id if the element is inside the boundaries.
     * ItemDragState is updated following receipt of the id.
     */
    handleDragOver(event) {
        var _a;
        if (!this.itemDragState || !((_a = this.itemDragState) === null || _a === void 0 ? void 0 : _a.mouseInteracted))
            return;
        const { clientX, clientY } = event;
        this.updateNodeAndDragState(clientX, clientY);
    }
    /**
     * Enabled use to move drag item left or right and calls handleDrop on drop.
     */
    handleKeyDown(event) {
        var _a, _b;
        if (!this.itemDragState || ((_a = this.itemDragState) === null || _a === void 0 ? void 0 : _a.mouseInteracted))
            return;
        let clientX = this.itemDragState.translation.x;
        const clientY = this.itemDragState.translation.y;
        // Move right or left
        if (event.key.toLowerCase() === KEYBOARD_RIGHT || event.key.toLowerCase() === KEYBOARD_LEFT) {
            clientX = event.key.toLowerCase() === KEYBOARD_RIGHT ? clientX + 5 : clientX - 5;
            this.updateNodeAndDragState(clientX, clientY);
            event.preventDefault();
            // Drop Item
        }
        else if (event.key.toLowerCase() === KEYBOARD_ENTER && ((_b = this.itemDragState) === null || _b === void 0 ? void 0 : _b.dropColumnId)) {
            this.handleDrop();
            return;
            // Exit on Escape Or Tab
        }
        else if (event.key.toLowerCase() === KEYBOARD_ESCAPE || event.key.toLowerCase() === KEYBOARD_TAB) {
            this.itemDragState = null;
            return;
        }
    }
    /**
     * Calls getItemWithinBounds to check the bounds for drop.
     * Updates node class if within bound and updated the itemDragState.
     * @param clientX x-cordinate
     * @param clientY y-cordinate
     */
    updateNodeAndDragState(clientX, clientY) {
        const translation = {
            x: clientX,
            y: clientY,
        };
        const node = this.getItemWithinBounds(clientX, clientY);
        let newDragState = Object.assign(Object.assign({}, this.itemDragState), { translation });
        const dropColumnId = node && node.getAttribute(HTML_ATTR_DATA_ACCESSOR_KEY);
        if (dropColumnId && dropColumnId !== newDragState.draggedColumnId) {
            newDragState = Object.assign(Object.assign({}, newDragState), { dropColumnId: dropColumnId, dropIndicator: node.getBoundingClientRect() });
        }
        else {
            newDragState = Object.assign(Object.assign({}, newDragState), { dropIndicator: null });
        }
        this.itemDragState = Object.assign({}, newDragState);
    }
    /**
     * Reorders columns when dropped in drop zone.
     */
    handleDrop() {
        if (!this.itemDragState)
            return;
        const dropItemId = this.itemDragState.dropColumnId;
        const draggedColumnId = this.itemDragState.draggedColumnId;
        const newColumnOrder = [...this.columnOrder];
        // Logic for column reordering.
        if (dropItemId) {
            newColumnOrder.splice(newColumnOrder.indexOf(dropItemId), 0, newColumnOrder.splice(newColumnOrder.indexOf(draggedColumnId), 1)[0]);
            this.columnOrder = [...newColumnOrder];
            this.table.options.state.columnOrder = newColumnOrder;
        }
        this.itemDragState = null;
    }
    /**
     * This function determines if an object is in a drop zone or not while dragging it.
     * @param x x-cordinate
     * @param y y-cordinate
     * @returns Drop zone element
     */
    getItemWithinBounds(x, y) {
        const node = Object.values(this.headersList).find((content) => {
            const rect = content === null || content === void 0 ? void 0 : content.getBoundingClientRect();
            if (rect) {
                const inVerticalBounds = y >= rect.top && y <= rect.bottom;
                const inHorizontalBounds = x >= rect.left && x <= rect.right;
                return inVerticalBounds && inHorizontalBounds;
            }
            return false;
        });
        return node;
    }
}
