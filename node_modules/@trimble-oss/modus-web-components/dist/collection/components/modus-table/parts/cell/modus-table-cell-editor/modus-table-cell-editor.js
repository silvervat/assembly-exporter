var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
// eslint-disable-next-line
import { Host, h } from "@stencil/core";
import { KEYBOARD_ENTER, CELL_EDIT_TYPE_AUTOCOMPLETE, CELL_EDIT_TYPE_DATE, CELL_EDIT_TYPE_SELECT, CELL_EDIT_TYPE_TEXT, CELL_EDIT_TYPE_INT, KEYBOARD_UP, KEYBOARD_DOWN, } from "../../../modus-table.constants";
import { createPopper } from "@popperjs/core";
export class ModusTableCellEditor {
    constructor() {
        this.handleBlur = () => {
            this.valueChange(this.editedValue);
            this.destroyErrorTooltip();
        };
        this.handleKeyDown = (e) => {
            this.keyDown(e, this.editedValue);
        };
        this.handleError = (e) => {
            this.errorMessage = e.detail;
            this.showErrorTooltip();
        };
        this.getDefaultProps = (ariaLabel) => ({
            'aria-label': ariaLabel,
            class: 'editor',
            ref: (ref) => (this.inputElement = ref),
        });
        this.args = undefined;
        this.dataType = undefined;
        this.value = undefined;
        this.type = undefined;
        this.valueChange = undefined;
        this.keyDown = undefined;
        this.errorMessage = undefined;
    }
    connectedCallback() {
        this.editedValue = this.value;
    }
    componentDidLoad() {
        if (this.inputElement['focusInput']) {
            this.inputElement['focusInput']();
        }
        this.createErrorTooltip();
    }
    disconnectedCallback() {
        this.destroyErrorTooltip();
    }
    handleDocumentClick(event) {
        if (this.type != 'date') {
            return;
        }
        const target = event.target;
        if (!this.inputElement.contains(target)) {
            this.handleBlur();
        }
    }
    createErrorTooltip() {
        if (!this.errorTooltip) {
            this.errorTooltip = document.createElement('div');
            this.errorTooltip.className = 'error-tooltip';
            this.inputElement.getRootNode().appendChild(this.errorTooltip); // Append to the same parent element as input
            this.popperInstance = createPopper(this.inputElement, this.errorTooltip, {
                placement: 'bottom-start',
                modifiers: [
                    {
                        name: 'offset',
                        options: {
                            offset: [-0.5, 0], // Offset from the element
                        },
                    },
                    {
                        name: 'preventOverflow',
                        options: {
                            boundary: 'viewport', // Prevents tooltip from overflowing the viewport
                        },
                    },
                ],
            });
        }
    }
    showErrorTooltip() {
        if (this.errorTooltip) {
            this.errorTooltip.innerText = this.errorMessage;
            this.errorTooltip.style.display = 'block';
            if (this.popperInstance) {
                this.popperInstance.update();
            }
        }
    }
    hideErrorTooltip() {
        if (this.errorTooltip) {
            this.errorTooltip.style.display = 'none';
        }
    }
    destroyErrorTooltip() {
        if (this.popperInstance) {
            this.popperInstance.destroy();
            this.popperInstance = null;
        }
        if (this.errorTooltip) {
            this.errorTooltip.remove();
            this.errorTooltip = null;
        }
    }
    renderNumberInput() {
        function handleArrowKeys(e, callback) {
            const code = e.key.toLowerCase();
            if (code === KEYBOARD_UP || code === KEYBOARD_DOWN) {
                e.stopPropagation();
            }
            else
                callback(e);
        }
        return (h("modus-number-input", Object.assign({}, this.getDefaultProps('Number input'), { value: this.value, textAlign: "right", size: "large", onBlur: this.handleBlur, onValueChange: (e) => (this.editedValue = e.detail), onKeyDown: (e) => handleArrowKeys(e, this.handleKeyDown) })));
    }
    renderTextInput() {
        return (h("modus-text-input", Object.assign({}, this.getDefaultProps('Text input'), { value: this.value, onValueChange: (e) => (this.editedValue = e.detail), onBlur: this.handleBlur, onKeyDown: this.handleKeyDown, autoFocusInput: true, size: "large" })));
    }
    renderSelectInput() {
        const valueKey = 'display';
        const args = this.args;
        const options = (args === null || args === void 0 ? void 0 : args.options) || [];
        const optionsDisplayProp = (args === null || args === void 0 ? void 0 : args.optionsDisplayProp) || valueKey;
        const placeholder = args === null || args === void 0 ? void 0 : args.placeholder;
        const selectedOption = options.find((option) => option[optionsDisplayProp] === this.value);
        function handleEnter(e, callback) {
            const code = e.key.toLowerCase();
            if (code === KEYBOARD_ENTER) {
                e.stopPropagation();
            }
            else
                callback(e);
        }
        return (h("div", null, h("modus-select", Object.assign({}, this.getDefaultProps('Select input'), { value: selectedOption, "options-display-prop": optionsDisplayProp, size: "large", options: options, placeholder: placeholder, onInputBlur: this.handleBlur, onKeyDown: (e) => handleEnter(e, this.handleKeyDown), onValueChange: (e) => {
                const detail = e.detail;
                if (this.dataType === 'badge') {
                    const { display } = detail, restProps = __rest(detail, ["display"]);
                    this.editedValue = Object.assign(Object.assign({}, restProps), { text: display });
                }
                else if (this.dataType === 'link') {
                    this.editedValue = detail;
                }
                else {
                    this.editedValue = detail[valueKey];
                }
            } }))));
    }
    renderDateInput() {
        var _a;
        const valueKey = 'value';
        const format = (_a = this.args) === null || _a === void 0 ? void 0 : _a.format;
        return (h("modus-date-picker", { onBlur: this.handleBlur, onClick: (e) => e.stopPropagation(), class: "date-picker-container" }, h("modus-date-input", Object.assign({}, this.getDefaultProps('Date input'), { format: format, size: "large", "show-calendar-icon": "true", value: this.value, onValueChange: (e) => {
                this.editedValue = e.detail[valueKey];
                this.hideErrorTooltip();
            }, onValueError: (e) => this.handleError(e) }))));
    }
    renderAutocompleteInput() {
        var _a, _b;
        const args = this.args;
        let options = [];
        let selectedOption = '';
        if (this.dataType === 'badge') {
            options = args === null || args === void 0 ? void 0 : args.options.map((option) => option.text);
            selectedOption = ((_a = this.value) === null || _a === void 0 ? void 0 : _a.text) || '';
        }
        else if (this.dataType === 'link') {
            options = args === null || args === void 0 ? void 0 : args.options.map((option) => option.display);
            selectedOption = ((_b = this.value) === null || _b === void 0 ? void 0 : _b.display) || '';
        }
        else {
            options = ((args === null || args === void 0 ? void 0 : args.options) || []);
            selectedOption = this.editedValue;
        }
        return (h("div", { class: "autocomplete-container" }, h("modus-autocomplete", Object.assign({}, this.getDefaultProps('Autocomplete input'), { "include-search-icon": "false", size: "medium", options: options, onBlur: this.handleBlur, onKeyDown: (e) => e.stopPropagation(), onOptionSelected: (e) => {
                const selectedDetail = e.detail;
                if (this.dataType === 'badge') {
                    const selectedOption = args === null || args === void 0 ? void 0 : args.options.find((option) => option.text === selectedDetail);
                    this.editedValue = selectedOption;
                }
                else if (this.dataType === 'link') {
                    const selectedOption = args === null || args === void 0 ? void 0 : args.options.find((option) => option.display === selectedDetail);
                    this.editedValue = selectedOption;
                }
                else {
                    this.editedValue = selectedDetail;
                }
            }, value: selectedOption }))));
    }
    renderEditor() {
        switch (this.type) {
            case CELL_EDIT_TYPE_SELECT:
                return this.renderSelectInput();
            case CELL_EDIT_TYPE_AUTOCOMPLETE:
                return this.renderAutocompleteInput();
            case CELL_EDIT_TYPE_DATE:
                return this.renderDateInput();
            case CELL_EDIT_TYPE_INT:
                return this.renderNumberInput();
            case CELL_EDIT_TYPE_TEXT:
            default:
                return this.renderTextInput();
        }
    }
    render() {
        return h(Host, { key: '27197918d3cbb8d084d13c51c3ec4be2ae27038d' }, this.renderEditor());
    }
    static get is() { return "modus-table-cell-editor"; }
    static get originalStyleUrls() {
        return {
            "$": ["./modus-table-cell-editor.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["modus-table-cell-editor.css"]
        };
    }
    static get properties() {
        return {
            "args": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "ModusTableCellEditorArgs",
                    "resolved": "{ format: string; } | { options: unknown[]; optionsDisplayProp?: string; placeholder?: string; }",
                    "references": {
                        "ModusTableCellEditorArgs": {
                            "location": "import",
                            "path": "../../../models/modus-table.models",
                            "id": "src/components/modus-table/models/modus-table.models.ts::ModusTableCellEditorArgs"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": ""
                }
            },
            "dataType": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "attribute": "data-type",
                "reflect": false
            },
            "value": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "unknown",
                    "resolved": "unknown",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": ""
                }
            },
            "type": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "attribute": "type",
                "reflect": false
            },
            "valueChange": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "(newValue: string) => void",
                    "resolved": "(newValue: string) => void",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": ""
                }
            },
            "keyDown": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "(e: KeyboardEvent, newValue: string) => void",
                    "resolved": "(e: KeyboardEvent, newValue: string) => void",
                    "references": {
                        "KeyboardEvent": {
                            "location": "global",
                            "id": "global::KeyboardEvent"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": ""
                }
            }
        };
    }
    static get states() {
        return {
            "errorMessage": {}
        };
    }
    static get listeners() {
        return [{
                "name": "click",
                "method": "handleDocumentClick",
                "target": "document",
                "capture": false,
                "passive": false
            }];
    }
}
