import { Host, h, // eslint-disable-line @typescript-eslint/no-unused-vars
 } from "@stencil/core";
import { COLUMN_DEF_DATATYPE_KEY, COLUMN_DEF_DATATYPE_INTEGER, COLUMN_DEF_CELL_EDITOR_TYPE_KEY, ALLOWED_CELL_EDIT_TYPES, CELL_EDIT_TYPE_TEXT, COLUMN_DEF_CELL_EDITOR_ARGS_KEY, COLUMN_DEF_DATATYPE_LINK, KEYBOARD_ENTER, KEYBOARD_ESCAPE, COLUMN_DEF_DATATYPE_BADGE, } from "../../../modus-table.constants";
import NavigateTableCells from "../../../utilities/table-cell-navigation.utility";
import { CellFormatter } from "../../../utilities/table-cell-formatter.utility";
import { ModusTableCellLinkElement } from "../modus-table-cell-link-element";
import { ModusTableCellBadgeElement } from "../modus-table-cell-badge-element";
import ModusTableCellExpandIcons from "../modus-table-cell-expand-icons";
export class ModusTableCellMain {
    constructor() {
        this.onCellClick = (e) => this.handleCellClick(e);
        this.onCellKeyDown = (e) => this.handleCellKeydown(e);
        this.onCellBlur = (e) => this.handleCellBlur(e);
        this.cellEditableKey = 'cellEditable';
        this.accessorKey = 'accessorKey';
        this.handleCellClick = (event) => {
            if (event.defaultPrevented)
                return;
            if (this.cell.column.columnDef[this.cellEditableKey]) {
                this.editMode = true;
            }
        };
        this.handleCellBlur = (event) => {
            if (!this.el.contains(event.relatedTarget)) {
                this.editMode = false;
            }
        };
        this.handleCellKeydown = (event) => {
            var _a;
            if (event.defaultPrevented)
                return;
            const key = (_a = event.key) === null || _a === void 0 ? void 0 : _a.toLowerCase();
            const isCellEditable = this.cell.column.columnDef[this.cellEditableKey];
            if (isCellEditable && !this.editMode && key === KEYBOARD_ENTER) {
                this.editMode = true;
                event.stopPropagation();
            }
            else {
                NavigateTableCells({
                    eventKey: event.key,
                    cellElement: this.cellEl,
                });
            }
        };
        this.handleCellEditorKeyDown = (event, newValue, oldValue) => {
            var _a;
            const key = (_a = event.key) === null || _a === void 0 ? void 0 : _a.toLowerCase();
            if (key === KEYBOARD_ENTER) {
                this.handleCellEditorValueChange(newValue, oldValue);
                NavigateTableCells({
                    eventKey: KEYBOARD_ENTER,
                    cellElement: this.cellEl,
                });
            }
            else if (key === KEYBOARD_ESCAPE) {
                this.editMode = false;
                this.cellEl.focus();
            }
            else
                return;
            event.stopPropagation();
        };
        this.cell = undefined;
        this.context = undefined;
        this.hasRowsExpandable = undefined;
        this.valueChange = undefined;
        this.editMode = undefined;
    }
    onEditModeChange(newValue) {
        if (newValue)
            this.cellEl.classList.add('edit-mode');
        else
            this.cellEl.classList.remove('edit-mode');
    }
    connectedCallback() {
        this.cellEl = this.el.parentElement;
        this.cellEl.addEventListener('click', this.onCellClick);
        this.cellEl.addEventListener('keydown', this.onCellKeyDown);
        this.cellEl.addEventListener('blur', this.onCellBlur);
    }
    disconnectedCallback() {
        if (this.cellEl) {
            this.cellEl.removeEventListener('click', this.onCellClick);
            this.cellEl.removeEventListener('keydown', this.onCellKeyDown);
            this.cellEl.removeEventListener('blur', this.onCellBlur);
        }
    }
    getEditorType() {
        const editorType = this.cell.column.columnDef[COLUMN_DEF_CELL_EDITOR_TYPE_KEY];
        const dataType = this.cell.column.columnDef[COLUMN_DEF_DATATYPE_KEY];
        let editorTypeToReturn = CELL_EDIT_TYPE_TEXT;
        if (!editorType) {
            if (ALLOWED_CELL_EDIT_TYPES.includes(dataType))
                editorTypeToReturn = dataType;
        }
        else {
            editorTypeToReturn = editorType;
        }
        return editorTypeToReturn;
    }
    getEditorArgs() {
        return this.cell.column.columnDef[COLUMN_DEF_CELL_EDITOR_ARGS_KEY];
    }
    /**
     * Returns whether a cell is editable based on row index and column ID.
     * @param rowIndex The index of the row.
     * @param columnId The ID of the column.
     * @returns Boolean indicating if the cell is editable.
     */
    async handleCellEdit(rowIndex, columnId) {
        const tableInstance = this.cell.getContext().table;
        const row = tableInstance.getRowModel().rows[rowIndex];
        if (!row)
            return;
        const cell = row.getAllCells().find((cell) => cell.column.id === columnId);
        if (!cell)
            return;
        // Focus on the cell element
        const cellElement = this.el.querySelector(`[data-cell-id="${rowIndex}-${columnId}"]`);
        if (cellElement) {
            cellElement.focus();
        }
        this.editMode = true;
    }
    handleCellEditorValueChange(newValue, oldValue) {
        if (this.editMode && newValue !== oldValue && this.valueChange) {
            this.valueChange({
                row: this.cell.row,
                accessorKey: this.cell.column.columnDef[this.accessorKey],
                newValue,
                oldValue,
            });
        }
        this.editMode = false;
    }
    renderCellValue() {
        var _a;
        const { row, getValue } = this.cell;
        const cellValue = getValue();
        if (cellValue === null || cellValue === undefined)
            return null;
        const { cellLinkClick, wrapText } = this.context;
        const cellDataType = (_a = cellValue['_type']) !== null && _a !== void 0 ? _a : this.cell.column.columnDef[COLUMN_DEF_DATATYPE_KEY];
        const wrap = cellDataType === COLUMN_DEF_DATATYPE_BADGE ? false : wrapText;
        const classes = {
            'cell-content': true,
            'truncate-text': !wrap,
            'wrap-text': wrap,
            'text-align-right': cellDataType === COLUMN_DEF_DATATYPE_INTEGER,
        };
        const renderCell = () => {
            if (cellDataType === COLUMN_DEF_DATATYPE_LINK) {
                return (h(ModusTableCellLinkElement, { link: cellValue, onLinkClick: (link) => {
                        this.cellEl.focus();
                        cellLinkClick.emit(link);
                    } }));
            }
            else if (cellDataType === COLUMN_DEF_DATATYPE_BADGE) {
                return (h(ModusTableCellBadgeElement, { badge: cellValue, onBadgeClick: () => {
                        this.cellEl.focus();
                    } }));
            }
            else {
                return CellFormatter(this.cell.column.columnDef.cell, this.cell.getContext());
            }
        };
        return (h("div", { class: classes }, this.hasRowsExpandable && h(ModusTableCellExpandIcons, { row: row }), h("span", { class: wrap ? 'wrap-text' : 'truncate-text' }, renderCell())));
    }
    render() {
        var _a;
        const valueString = (_a = this.cell.getValue()) === null || _a === void 0 ? void 0 : _a.toString();
        return (h(Host, { key: 'df7d9a18b6bc172a9f8dd51521b5ddcca1fb9e9c' }, this.editMode ? (h("modus-table-cell-editor", { "data-type": this.cell.column.columnDef[COLUMN_DEF_DATATYPE_KEY], value: this.cell.getValue(), type: this.getEditorType(), args: this.getEditorArgs(), valueChange: (newVal) => this.handleCellEditorValueChange(newVal, valueString), keyDown: (event, newVal) => this.handleCellEditorKeyDown(event, newVal, valueString) })) : (this.renderCellValue())));
    }
    static get is() { return "modus-table-cell-main"; }
    static get properties() {
        return {
            "cell": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "Cell<unknown, unknown>",
                    "resolved": "Cell<unknown, unknown>",
                    "references": {
                        "Cell": {
                            "location": "import",
                            "path": "@tanstack/table-core",
                            "id": ""
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": ""
                }
            },
            "context": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "TableContext",
                    "resolved": "TableContext",
                    "references": {
                        "TableContext": {
                            "location": "import",
                            "path": "../../../models/table-context.models",
                            "id": "src/components/modus-table/models/table-context.models.ts::TableContext"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": ""
                }
            },
            "hasRowsExpandable": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "attribute": "has-rows-expandable",
                "reflect": false
            },
            "valueChange": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "(props: TableCellEdited) => void",
                    "resolved": "(props: TableCellEdited) => void",
                    "references": {
                        "TableCellEdited": {
                            "location": "import",
                            "path": "../../../models/table-context.models",
                            "id": "src/components/modus-table/models/table-context.models.ts::TableCellEdited"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": ""
                }
            }
        };
    }
    static get states() {
        return {
            "editMode": {}
        };
    }
    static get methods() {
        return {
            "handleCellEdit": {
                "complexType": {
                    "signature": "(rowIndex: string, columnId: string) => Promise<void>",
                    "parameters": [{
                            "name": "rowIndex",
                            "type": "string",
                            "docs": "The index of the row."
                        }, {
                            "name": "columnId",
                            "type": "string",
                            "docs": "The ID of the column."
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "HTMLElement": {
                            "location": "global",
                            "id": "global::HTMLElement"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Returns whether a cell is editable based on row index and column ID.",
                    "tags": [{
                            "name": "param",
                            "text": "rowIndex The index of the row."
                        }, {
                            "name": "param",
                            "text": "columnId The ID of the column."
                        }, {
                            "name": "returns",
                            "text": "Boolean indicating if the cell is editable."
                        }]
                }
            }
        };
    }
    static get elementRef() { return "el"; }
    static get watchers() {
        return [{
                "propName": "editMode",
                "methodName": "onEditModeChange"
            }];
    }
}
