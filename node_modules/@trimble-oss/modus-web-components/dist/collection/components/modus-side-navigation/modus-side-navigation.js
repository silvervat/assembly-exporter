import { h, // eslint-disable-line @typescript-eslint/no-unused-vars
 } from "@stencil/core";
import { IconChevronLeft } from "../../icons/generated-icons/IconChevronLeft";
import { ModusSideNavigationTree } from "./modus-side-navigation-tree";
export class ModusSideNavigation {
    constructor() {
        this._callbackQueue = []; // eslint-disable-line @typescript-eslint/no-explicit-any
        this._children = {};
        this._minWidth = '4rem';
        this._retainFocus = false;
        // Trick to restart an element's animation
        // see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
        // taken from: https://getbootstrap.com/docs/5.2/dist/js/bootstrap.js
        this.reflow = (element) => {
            element.offsetHeight; // eslint-disable-line no-unused-expressions
        };
        this.collapseOnClickOutside = true;
        this.data = undefined;
        this.maxWidth = '256px';
        this.mode = 'overlay';
        this.expanded = false;
        this.targetContent = undefined;
        this._navigationLevels = [];
    }
    componentDidRender() {
        var _a;
        // Execute the callbacks on Render
        // Be careful with updating states in these callbacks to avoid infinite looping
        if ((_a = this._callbackQueue) === null || _a === void 0 ? void 0 : _a.length) {
            this._callbackQueue.forEach((callbackFn) => callbackFn && callbackFn());
        }
        this._callbackQueue = [];
    }
    componentWillLoad() {
        this.handleExpandedChange(this.expanded);
        // If data prop is set, get the level1 info
        this.initializeLevelInfo(this.data);
    }
    documentClickHandler(event) {
        if (!this.collapseOnClickOutside || this.element.contains(event.target) || event.defaultPrevented)
            return;
        // Collapse when clicked outside
        this.expanded = false;
    }
    getNextLevel(id) {
        var _a;
        if ((_a = this._navigationLevels) === null || _a === void 0 ? void 0 : _a.length) {
            const existingLevelItems = this._navigationLevels[this._navigationLevels.length - 1].children;
            return existingLevelItems === null || existingLevelItems === void 0 ? void 0 : existingLevelItems.find((i) => i.id === id);
        }
        return null;
    }
    gotoNextLevel(id) {
        var _a;
        if ((_a = this._navigationLevels) === null || _a === void 0 ? void 0 : _a.length) {
            const level = this.getNextLevel(id);
            if (level === null || level === void 0 ? void 0 : level.children) {
                const newLevels = [...(this._navigationLevels || [])];
                newLevels.push(Object.assign(Object.assign({}, level), { levelPosition: 'right' }));
                this._navigationLevels = [...newLevels];
                this.expanded = true;
                // Animation for sliding levels
                this._callbackQueue.push(() => {
                    const levels = [...this._navigationLevels];
                    levels.forEach((level, index) => {
                        if (index === levels.length - 2) {
                            level.levelPosition = 'left';
                        }
                        else if (index === levels.length - 1) {
                            level.levelPosition = 'center';
                        }
                    });
                    this._navigationLevels = [...levels];
                    this._retainFocus = true;
                });
                return true;
            }
        }
        return false;
    }
    gotoPreviousLevel() {
        var _a, _b;
        if (!((_a = this._navigationLevels) === null || _a === void 0 ? void 0 : _a.length) || ((_b = this._navigationLevels) === null || _b === void 0 ? void 0 : _b.length) === 1)
            return false;
        const levels = [...this._navigationLevels];
        // Animation for sliding levels
        levels.forEach((level, index) => {
            if (levels.length > 1) {
                if (index === levels.length - 2) {
                    level.levelPosition = 'center';
                }
                else if (index === levels.length - 1) {
                    level.levelPosition = 'right';
                }
            }
            else {
                level.levelPosition = 'center';
            }
        });
        this._navigationLevels = [...levels];
        this._callbackQueue.push(() => {
            this._timeout = setTimeout(() => {
                levels.pop();
                this._navigationLevels = [...levels];
                this._retainFocus = true;
                clearTimeout(this._timeout);
            }, 250);
        });
        return true;
    }
    handleItemAdded(event) {
        var _a;
        if ((_a = event.detail) === null || _a === void 0 ? void 0 : _a.id) {
            this._children[event.detail.id] = event.detail;
            this._children[event.detail.id].expanded = this.expanded;
        }
        this.itemChanged(event);
    }
    handleItemRemoved(event) {
        var _a;
        if ((_a = event.detail) === null || _a === void 0 ? void 0 : _a.id) {
            delete this._children[event.detail.id];
        }
        this.itemChanged(event);
    }
    handleItemFocus(event) {
        this.setFocusItem(event.detail.id);
    }
    handleItemClick(event) {
        if (!this.gotoNextLevel(event.detail.id)) {
            if (this._itemSelected) {
                this._children[this._itemSelected].selected = false;
                this._itemSelected = null;
            }
            this._itemSelected = event.detail.selected ? event.detail.id : null;
        }
    }
    handleDataChange(val) {
        this.initializeLevelInfo(val);
    }
    handleExpandedChange(expand) {
        var _a;
        const toggleNavItems = () => {
            Object.values(this._children).forEach((c) => (c.expanded = expand));
        };
        const adjustTargetContent = () => {
            this.setTargetContentMargin(expand, this.mode, this.targetContent);
        };
        const emitExpandedEvent = () => {
            var _a;
            (_a = this.sideNavExpand) === null || _a === void 0 ? void 0 : _a.emit(this.expanded);
        };
        const levelHeading = (_a = this._levelsContainerRef) === null || _a === void 0 ? void 0 : _a.querySelector('.side-nav-level.center .level-heading');
        // Trigger Animation if the current level has a heading
        if (levelHeading) {
            if (expand) {
                levelHeading.classList.remove('collapse');
                levelHeading.classList.add('collapsing');
                levelHeading.style.height = '0';
                this._timeout = setTimeout(() => {
                    levelHeading.classList.remove('collapsing');
                    levelHeading.classList.add('show');
                    levelHeading.style.height = '';
                    clearTimeout(this._timeout);
                    toggleNavItems();
                    emitExpandedEvent();
                }, 150);
                levelHeading.style.height = `${levelHeading.scrollHeight}px`;
                adjustTargetContent();
            }
            else {
                toggleNavItems();
                levelHeading.style.height = `${levelHeading.getBoundingClientRect().height}px`;
                this.reflow(levelHeading);
                levelHeading.classList.add('collapsing');
                // Timeout to reset collapsing class
                this._timeout = setTimeout(() => {
                    levelHeading.classList.remove('show');
                    levelHeading.classList.remove('collapsing');
                    levelHeading.classList.add('collapse');
                    clearTimeout(this._timeout);
                    emitExpandedEvent();
                }, 300);
                levelHeading.style.height = '0px';
                adjustTargetContent();
            }
        }
        else {
            toggleNavItems();
            adjustTargetContent();
            emitExpandedEvent();
        }
    }
    handleModeChange(mode) {
        this.setTargetContentMargin(this.expanded, mode, this.targetContent);
    }
    handleTargetChange(target) {
        this.setTargetContentMargin(this.expanded, this.mode, target);
    }
    handleBackClick(e) {
        var _a;
        const code = (_a = e['code']) === null || _a === void 0 ? void 0 : _a.toUpperCase();
        if (code) {
            if (code === 'ENTER' || code === 'SPACE') {
                this.gotoPreviousLevel();
            }
        }
        else
            this.gotoPreviousLevel();
        e.stopPropagation();
    }
    handleKeyDown(event) {
        var _a, _b;
        if (event.defaultPrevented) {
            return; // Do nothing if event already handled
        }
        const key = event.code.toUpperCase();
        let preventDefault = false;
        // If the tree is empty there will be no child
        if (event.altKey || !this._firstChild) {
            return;
        }
        switch (key) {
            case 'SPACE':
            case 'ENTER':
                event.stopPropagation();
                break;
            case 'ARROWDOWN':
                // eslint-disable-next-line no-case-declarations
                const nextItem = (_a = this._children[this._itemInFocus]) === null || _a === void 0 ? void 0 : _a.nextElementSibling;
                nextItem === null || nextItem === void 0 ? void 0 : nextItem.focusItem();
                preventDefault = true;
                break;
            case 'ARROWUP':
                // eslint-disable-next-line no-case-declarations
                const prevItem = (_b = this._children[this._itemInFocus]) === null || _b === void 0 ? void 0 : _b.previousElementSibling;
                prevItem === null || prevItem === void 0 ? void 0 : prevItem.focusItem();
                preventDefault = true;
                break;
            case 'ARROWRIGHT':
                if (this.expanded)
                    this.gotoNextLevel(this._itemInFocus);
                break;
            case 'ARROWLEFT':
                if (this.expanded)
                    this.gotoPreviousLevel();
                break;
            default:
        }
        if (preventDefault) {
            event.preventDefault();
            event.stopPropagation();
        }
    }
    handleLevelsContainerRef(el) {
        this._levelsContainerRef = el;
        // Workaround to retain focus on the component in specific cases
        // Like going back to a level, the component loses focus
        if (this._retainFocus)
            el.focus();
        this._retainFocus = false;
    }
    handleLevelHeadingRef(el) {
        // Retain focus on the current level headings
        el === null || el === void 0 ? void 0 : el.focus();
    }
    initializeLevelInfo(data) {
        if (data === null || data === void 0 ? void 0 : data.length) {
            this._navigationLevels = [
                {
                    id: null,
                    label: null,
                    children: data,
                    levelPosition: 'center',
                },
            ];
        }
        else
            this._navigationLevels = null;
    }
    itemChanged(event) {
        const keys = Object.keys(this._children);
        this._firstChild = keys[0];
        event.preventDefault();
        event.stopPropagation();
    }
    setTargetContentMargin(isExpanded, mode, target) {
        const content = document.querySelector(target);
        if (content) {
            content.style.marginLeft = isExpanded && mode === 'push' ? this.maxWidth : this._minWidth;
        }
    }
    setFocusItem(itemId) {
        this._itemInFocus = itemId;
    }
    render() {
        return (h("nav", { key: 'bdeaa37cdf3b1f0b39999fd1a79d4b9f46e095e3', class: `side-nav-panel${this.expanded ? ' expanded' : ''}`, style: { width: this.expanded ? this.maxWidth : null }, onKeyDown: (e) => this.handleKeyDown(e), "aria-label": "side navigation" }, this.data ? (h("div", { tabindex: -1, ref: (el) => this.handleLevelsContainerRef(el) }, this._navigationLevels.map((level, index) => (h("div", { class: `side-nav-level ${level.levelPosition}`, "aria-hidden": level.levelPosition !== 'center' ? 'true' : null }, index !== 0 && (h("div", Object.assign({ class: "level-heading" }, (level.levelPosition === 'center'
            ? {
                tabindex: 0,
                ref: (el) => this.handleLevelHeadingRef(el),
            }
            : {})), h("p", null, h(IconChevronLeft, { size: "24" }), h("a", { tabIndex: 0, onClick: (e) => this.handleBackClick(e), onKeyDown: (e) => this.handleBackClick(e) }, "Back")), h("h4", null, level.label))), h("div", null, h("ul", { class: "side-nav-menu", role: "tree" }, h(ModusSideNavigationTree, { data: level.children, itemSelected: this._itemSelected, tabIndex: level.levelPosition === 'center' ? undefined : -1 })))))))) : (h("div", { class: "side-nav-level center" }, h("ul", { class: "side-nav-menu", role: "tree" }, h("slot", null))))));
    }
    static get is() { return "modus-side-navigation"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["modus-side-navigation.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["modus-side-navigation.css"]
        };
    }
    static get properties() {
        return {
            "collapseOnClickOutside": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "(optional) To choose whether to collapse the panel when clicked outside."
                },
                "attribute": "collapse-on-click-outside",
                "reflect": false,
                "defaultValue": "true"
            },
            "data": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "ModusSideNavigationItemInfo[]",
                    "resolved": "ModusSideNavigationItemInfo[]",
                    "references": {
                        "ModusSideNavigationItemInfo": {
                            "location": "import",
                            "path": "./modus-side-navigation.models",
                            "id": "src/components/modus-side-navigation/modus-side-navigation.models.tsx::ModusSideNavigationItemInfo"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "(optional) Data property to create the items."
                }
            },
            "maxWidth": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "(optional) Maximum width of the side navigation panel in an expanded state."
                },
                "attribute": "max-width",
                "reflect": false,
                "defaultValue": "'256px'"
            },
            "mode": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "'overlay' | 'push'",
                    "resolved": "\"overlay\" | \"push\"",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Mode to make side navigation either overlay or push the content for the selector specified in `targetContent`"
                },
                "attribute": "mode",
                "reflect": false,
                "defaultValue": "'overlay'"
            },
            "expanded": {
                "type": "boolean",
                "mutable": true,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "(optional) The expanded state of side navigation panel and items."
                },
                "attribute": "expanded",
                "reflect": true,
                "defaultValue": "false"
            },
            "targetContent": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "(optional) Specify the selector for the page's content for which paddings and margins will be set by side navigation based on the `mode`."
                },
                "attribute": "target-content",
                "reflect": false
            }
        };
    }
    static get states() {
        return {
            "_navigationLevels": {}
        };
    }
    static get events() {
        return [{
                "method": "sideNavExpand",
                "name": "sideNavExpand",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "An event that fires on side navigation panel collapse & expand."
                },
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                }
            }];
    }
    static get elementRef() { return "element"; }
    static get watchers() {
        return [{
                "propName": "data",
                "methodName": "handleDataChange"
            }, {
                "propName": "expanded",
                "methodName": "handleExpandedChange"
            }, {
                "propName": "mode",
                "methodName": "handleModeChange"
            }, {
                "propName": "targetContent",
                "methodName": "handleTargetChange"
            }];
    }
    static get listeners() {
        return [{
                "name": "click",
                "method": "documentClickHandler",
                "target": "document",
                "capture": false,
                "passive": false
            }, {
                "name": "_sideNavItemAdded",
                "method": "handleItemAdded",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "_sideNavItemRemoved",
                "method": "handleItemRemoved",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "sideNavItemFocus",
                "method": "handleItemFocus",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "sideNavItemClicked",
                "method": "handleItemClick",
                "target": undefined,
                "capture": false,
                "passive": false
            }];
    }
}
